type=page
status=published
title=Reference
next=capi-error-codes.html
prev=client-design-issues.html
~~~~~~
Reference
=========

[[GMCCG00005]][[aeldi]]


[[reference]]
4 Reference
-----------

This chapter provides reference documentation for the Message Queue
C-API. It includes information about the following:

* link:#aeldj[Data Types] describes the C declarations for data types
used by Message Queue messaging
* link:#aeldo[Function Reference] describes the C functions that
implement Message Queue messaging
* link:#aelgo[Header Files] describes the contents of the C-API header
files

For information on building C-Message Queue programs, see
link:client-design-issues.html#aelcp[Client Design Issues].

For information on how you use the C API to complete specific
programming tasks, see link:using-the-c-api.html#aelba[Using the C API].

[[aeldj]][[GMCCG00056]][[data-types]]

Data Types
~~~~~~~~~~

link:#aeldj[Data Types] summarizes the data types defined by the Message
Queue C API. The table lists data types in alphabetical order and
provides cross references for types that require broader discussion.

Note that Message Queue data types designated as handles map to opaque
structures (objects). Please do not attempt to dereference these handles
to get to the underlying objects. Instead, use the functions provided to
access the referenced objects.

[[GMCCG441]][[sthref25]][[gblzn]]


Table 4-1 Message Queue C-API Data Type Summary

[width="100%",cols="48%,52%",options="header",]
|=======================================================================
|Message Queue Type |Description
|`ConstMQString` |A constant `MQString`.

|`MQAckMode` a|
An `enum` used to specify the acknowledgement mode of a session.
Possible values include the following:

* `MQ_AUTO_ACKNOWLEDGE`
* `MQ_CLIENT_ACKNOWLEDGE`
* `MQ_DUPS_OK_ACKNOWLEDGE`
* `MQ_SESSION_TRANSACTED`

See link:#aeldl[Acknowledge Modes] for more information.

|`MQBool` a|
A boolean that can assume one of two values:

[source,oac_no_warn]
----
MQ_TRUE(=1)
MQ_FALSE(=0).
----

|`MQChar` |`char` type.

|`MQConnectionHandle` |A handle used to reference a Message Queue
connection. You get this handle when you call the
link:#aeldy[MQCreateConnection] function.

|`MQConsumerHandle` |A handle used to reference a Message Queue
consumer. A consumer can be durable, nondurable and synchronous, or
asynchronous. You get this handle when you call one of the functions
used to create consumers. See link:using-the-c-api.html#aelch[Receiving
Messages] for more information.

|`MQDeliveryMode` a|
An `enum` used to specify whether a message is sent persistently:

* `MQ_NON_PERSISTENT_DELIVERY`
* `MQ_PERSISTENT_DELIVERY`

You specify this value with the link:#aelfu[MQSendMessageExt] function
or the link:#aelfw[MQSendMessageToDestinationExt] function.

|`MQDestinationHandle` |A handle used to reference a Message Queue
destination. You get this handle when you call the
link:#aeleb[MQCreateDestination] function or the
link:#aelei[MQCreateTemporaryDestination] function.

|`MQDestinationType` a|
An enum used to specify the type of a destination:

* `MQ_QUEUE_DESTINATION`
* `MQ_TOPIC_DESTINATION`

You set the destination type using the link:#aeleb[MQCreateDestination]
function or the link:#aelei[MQCreateTemporaryDestination] function.

|`MQError` |A 32-bit unsigned integer.

|`MQConnectionExceptionListenerFunc` |The type of a callback function
used for connection exception handling. For more information, see
link:#aeldn[Callback Type for Connection Exception Handling].

|`MQFloat32` |A 32-bit floating-point number.

a|
[source,oac_no_warn]
----
MQFloat64
----

 |A 64-bit floating-point number.

|`MQInt16` |A 16-bit signed integer.

|`MQInt32` |A 32-bit signed integer.

|`MQInt64` |A 64-bit signed integer.

|`MQInt8` |An 8-bit signed integer.

|`MQMessageHandle` |A handle used to reference a Message Queue message.
You get this handle when you call the link:#aeldx[MQCreateBytesMessage]
function, or the link:#aelej[MQCreateTextMessage] function, or on
receipt of a message.

|`MQMessageListenerFunc` |The type of a callback function used for
asynchronous message receipt. For more information, see
link:#aeldm[Callback Type for Asynchronous Message Consumption].

|`MQMessageType` a|
An `enum` passed back by the link:#aelfd[MQGetMessageType] and used to
specify the type of a message; possible values include the following:

* `MQ_TEXT_MESSAGE`
* `MQ_BYTES_MESSAGE`
* `MQ_MESSAGE`
* `MQ_UNSUPPORTED_MESSAGE`

|`MQProducerHandle` |A handle used to reference a Message Queue
producer. You get this handle when you call
link:#aelee[MQCreateMessageProducer] or
link:#aelef[MQCreateMessageProducerForDestination].

|`MQPropertiesHandle` |A handle used to reference Message Queue
properties. You use this handle to define or read connection properties
and message headers or message properties. See
link:using-the-c-api.html#aelbd[Working With Properties] for more
information.

|`MQReceiveMode` a|
An `enum` used to specify whether consumers are synchronous or
asynchronous. It can be one of the following:

* `MQ_SESSION_SYNC_RECEIVE`
* `MQ_SESSION_ASYNC_RECEIVE`

See link:#aeleh[MQCreateSession] for more information.

|`MQSessionHandle` |A handle used to reference a Message Queue session.
You get this handle when you call the link:#aeleh[MQCreateSession]
function.

|`MQStatus` |A data type returned by nearly all functions defined in
`mqcrt.h`. See link:using-the-c-api.html#aelcm[Error Handling] for more
information on how you handle errors returned by Message Queue
functions.

|`MQString` |A null terminated UTF-8 encoded character string

|`MQType` a|
An `enum` used to return the type of a single property; possible values
include the following:

* `MQ_INT8_TYPE`
* `MQ_INT16_TYPE`
* `MQ_INT32_TYPE`
* `MQ_INT64_TYPE`
* `MQ_FLOAT32_TYPE`
* `MQ_FLOAT64_TYPE`
* `MQ_STRING_TYPE`
* `MQ_INVALID_TYPE`

|=======================================================================


[[aeldk]][[GMCCG00333]][[connection-properties]]

Connection Properties
^^^^^^^^^^^^^^^^^^^^^

When you create a connection using the link:#aeldy[MQCreateConnection]
function, you must pass a handle to an object of type
`MQPropertiesHandle`. The following table lists and describes the key
values that define each property. The procedure that follows the table
explains how you set the properties referenced by this handle.

[[GMCCG442]][[sthref26]][[gcsrb]]


Table 4-2 Connection Properties

[width="100%",cols="44%,56%",options="header",]
|=======================================================================
|Key Name |Description
a|
[source,oac_no_warn]
----
MQ_CONNECTION_TYPE_PROPERTY
----

 a|
An `MQString` specifying the transport protocol of the connection
service used by the client. Supported types are `TCP` or `TLS` (`SSL`).
The TCP protocol underlies the `jms` service; the TLS protocol supports
the `ssljms` service.

Default: `TCP`

a|
[source,oac_no_warn]
----
MQ_ACK_TIMEOUT_PROPERTY
----

 a|
A 32-bit integer specifying the maximum time in milliseconds that the
client runtime will wait for any broker acknowledgement before returning
an `MQ_TIMEOUT_EXPIRED` error. A value of 0 means there is no time-out.

Default: `0`

a|
[source,oac_no_warn]
----
MQ_BROKER_HOST_PROPERTY
----

 a|
An `MQString` specifying the broker host name to which to connect.

If you set the property MQ_SSL_BROKER_IS_TRUSTED to `false`, the value
you specify for the property MQ_BROKER_HOST_PROPERTY must match the CN
(common name) of the broker's certificate.

No default.

a|
[source,oac_no_warn]
----
MQ_PING_INTERVAL_PROPERTY
----

 a|
A 32-bit integer specifying the interval (in seconds) that the
connection can remain idle before the client runtime tests the
connection by pinging the broker. (The exact amount of time it takes for
the ping to detect connection failure varies with the system's TCP
configuration.)

A ping interval that is <= 0 turns off the ping for the connection. The
minimum allowable interval is 1 second. This prevents an application
from setting the interval to a value that would affect performance.

The ping interval is logged at the INFO level by the C client runtime
when a connection is created.

Default: `30` seconds

a|
[source,oac_no_warn]
----
MQ_BROKER_PORT_PROPERTY
----

 a|
A 32-bit integer specifying the number of the port for the broker's port
mapper service.

No default.

a|
[source,oac_no_warn]
----
MQ_SERVICE_PORT_PROPERTY
----

 |A 32â€“bit integer that specifies the number of a port to which the
client connects. This is a static, fixed port assignment; it bypasses
the broker's port mapper service. If you do need to connect to a fixed
port on the broker, make sure that the service needed is enabled and
available at the specified port by setting the
`imq`.serviceName.protocolType.`port` broker property.

a|
[source,oac_no_warn]
----
MQ_ACK_ON_PRODUCE_PROPERTY
----

 a|
An `MQBool` specifying whether the producing client waits for broker
acknowledgement of receipt of message from the producing client.

If set to `MQ_TRUE`, the broker acknowledges receipt of all messages
(persistent and non-persistent) from the producing client, and the
producing client thread will block waiting for those acknowledgements.

If set to `MQ_FALSE`, broker does not acknowledge receipt of any message
(persistent or non-persistent) from the producing client, and the
producing client thread will not block waiting for broker
acknowledgements.

Default: the broker acknowledges receipt of persistent messages only
from the producing client, and the producing client thread will block
waiting for those acknowledgements.

a|
[source,oac_no_warn]
----
MQ_ACK_ON_ACKNOWLEDGE_PROPERTY
----

 a|
An `MQBool` specifying whether the broker confirms (acknowledges)
consumer acknowledgements. A consumer acknowledgement can be initiated
either by the client's session or by the consuming client, depending on
the session acknowledgement mode (see link:#aeldl[Acknowledge Modes]).
If the session's acknowledgement mode is `MQ_DUPS_OK_ACKNOWLEDGE`, this
flag has no effect.

If set to `MQ_TRUE`, the broker acknowledges all consuming
acknowledgements, and the consuming client thread blocks waiting for
these broker acknowledgements.

If set to `MQ_FALSE`, the broker does not acknowledge any consuming
client acknowledgements, and the consuming client thread will not block
waiting for such broker acknowledgements.

Default: `MQ_TRUE`

For more information, see the discussion for the
link:#aeldp[MQAcknowledgeMessages] function and
link:using-the-c-api.html#aelbt[Message Acknowledgement].

a|
[source,oac_no_warn]
----
MQ_CONNECTION_FLOW_COUNT_PROPERTY
----

 a|
A 32-bit integer, greater than 0, specifying the number of Message Queue
messages in a metered batch. When this number of messages is delivered
from the broker to the client runtime, delivery is temporarily
suspended, allowing any control messages that had been held up to be
delivered. Payload message delivery is resumed upon notification by the
client runtime, and continues until the count is again reached.

Default: `100`

a|
[source,oac_no_warn]
----
MQ_CONNECTION_FLOW_LIMIT_ENBABLED_PROPERTY
----

 a|
An `MQBool` specifying whether the value
`MQ_CONNECTION_FLOW_LIMIT_PROPERTY` is used to control message flow.
Specify `MQ_TRUE` to use the value and `MQ_FALSE` otherwise.

Default: `MQ_FALSE`

a|
[source,oac_no_warn]
----
MQ_CONNECTION_FLOW_LIMIT_PROPERTY
----

 a|
A 32-bit integer, greater than 0, specifying the maximum number of
unconsumed messages the client runtime can hold for each connection.
Note however, that unless `MQ_CONNECTION_FLOW_LIMIT_ENBABLED_PROPERTY`
is `MQ_TRUE`, this limit is not checked.

When the number of unconsumed messages held by the client runtime for
the connection exceeds the limit, message delivery stops. It is resumed
(in accordance with the flow metering governed by
`MQ_CONNECTION_FLOW_COUNT_PROPERTY`) only when the number of unconsumed
messages drops below the value set with this property.

This limit prevents a consuming client that is taking a long time to
process messages from being overwhelmed with pending messages that might
cause it to run out of memory.

Default: `1000`

a|
[source,oac_no_warn]
----
MQ_SSL_BROKER_IS_TRUSTED
----

 a|
An `MQ_Bool` specifying whether the broker is trusted.

Default: `MQ_TRUE`

a|
[source,oac_no_warn]
----
MQ_SSL_CHECK_BROKER_FINGERPRINT
----

 a|
An `MQ_Bool`. If it is set to `MQ_TRUE` and if
`MQ_SSL_BROKER_IS_TRUSTED` is `MQ_FALSE`, the broker's certificate
fingerprint is compared with the `MQ_SSL_BROKER_CERT_FINGERPRINT`
property value in case of certificate authorization failure. If they
match, the broker's certificate is authorized for use in the SSL
connection.

Default: `MQ_FALSE`

a|
[source,oac_no_warn]
----
MQ_SSL_BROKER_CERT_FINGERPRIN
----

 a|
An `MQString` specifying the MD5 hash, in hex format, of the broker's
certificate.

Default: `NULL`

a|
[source,oac_no_warn]
----
MQ_NAME_PROPERTY
----

 |An `MQString` that specifies the name of the Message Queue product.
This property is set by the runtime library. See
link:#aelfe[MQGetMetaData] for more information.

a|
[source,oac_no_warn]
----
MQ_VERSION_PROPERTY
----

 |An `MQInt32` that specifies the version of the Message Queue product.
This property is set by the runtime library. See
link:#aelfe[MQGetMetaData] for more information.

a|
[source,oac_no_warn]
----
MQ_MAJOR_VERSION_PROPERTY
----

 a|
An `MQInt32` that specifies the major version of the Message Queue
product. For example, if the version is 3.5.0.1, the major version would
be 3.

This property is set by the runtime library. See
link:#aelfe[MQGetMetaData] for more information.

a|
[source,oac_no_warn]
----
MQ_MINOR_VERSION_PROPERTY
----

 a|
An `MQInt32` that specifies the minor version of the Message Queue
product. For example, if the version is 3.5.0.1, the minor version would
be 5.

This property is set by the runtime library. See
link:#aelfe[MQGetMetaData] for more information.

a|
[source,oac_no_warn]
----
MQ_MICRO_VERSION_PROPERTY
----

 a|
An `MQInt32` that specifies the micro version of the Message Queue
product. For example, if the version is 3.5.0.1, the micro version would
be 0.

This property is set by the runtime library. See
link:#aelfe[MQGetMetaData] for more information.

a|
[source,oac_no_warn]
----
MQ_SERVICE_PACK_PROPERTY
----

 a|
An `MQInt32` that specifies the service pack version of the Message
Queue product. For example, if the version is 3.5.0.1, the service pack
version would be 1.

This property is set by the runtime library. See
link:#aelfe[MQGetMetaData] for more information.

a|
[source,oac_no_warn]
----
MQ_UPDATE_RELEASE_PROPERTY
----

 a|
An `MQInt32` that specifies the update release version of the Message
Queue product. For example, if the version is 3.7 UR1, the update
release value would be 1.

This property is set by the runtime library. See
link:#aelfe[MQGetMetaData] for more information.

|=======================================================================


[[gblzb]][[GMCCG00025]][[to-set-connection-properties]]

To Set Connection Properties
++++++++++++++++++++++++++++

1.  Call the `MQCreateProperties` function to get a handle to a newly
created properties object
2.  Call a function to set one of the connection properties listed in
link:#gcsrb[Table 4-2]. +
Which function you call depends on the type of the property you want to
set; for example, to set an `MQString` property, you call the
`MQSetStringProperty` function; to set a `MQBool` property, you call the
`MQSetBoolProperty` function; and so on. Each function that sets a
property requires that you pass a key name (constant) and value; these
are listed and described in link:#gcsrb[Table 4-2].
3.  When you have set all the properties you want to define for the
connection, you can then create the connection, by calling the
`MQCreateConnection` function. +
The runtime library sets the connection properties that specify the name
and version of the Message Queue product; you can retrieve these using
the link:#aelfe[MQGetMetaData] function. These properties are described
at the end of link:#gcsrb[Table 4-2], starting with `MQ_NAME_PROPERTY`.

[[aeldl]][[GMCCG00334]][[acknowledge-modes]]

Acknowledge Modes
^^^^^^^^^^^^^^^^^

The Message Queue runtime supports reliable delivery by using transacted
sessions or through acknowledgement options set at the session level.
When you use the link:#aeleh[MQCreateSession] function to create a
session, you must specify an acknowledgement option for that session
using the `acknowledgeMode` parameter. The value of this parameter is
ignored for transacted sessions.

link:#gblzy[Table 4-3]describes the effect of the options you can set
using the `acknowledgeMode` parameter.

[[GMCCG443]][[sthref27]][[gblzy]]


Table 4-3 `acknowledgeMode` Values

[width="100%",cols="30%,70%",options="header",]
|=======================================================================
|Enum |Description
a|
[source,oac_no_warn]
----
MQ_AUTO_ACKNOWLEDGE
----

 |The session automatically acknowledges each message consumed by the
client. This happens when one of the receive functions returns
successfully, or when the message listener processing the message
returns successfully.

a|
[source,oac_no_warn]
----
MQ_CLIENT_ACKNOWLEDGE
----

 |The client explicitly acknowledges all messages for the session that
have been consumed up to the point when the `MQAcknowledgeMessages`
function has been called. See the discussion of the function
link:#aeldp[MQAcknowledgeMessages] for additional information.

a|
[source,oac_no_warn]
----
MQ_DUPS_OK_ACKNOWLEDGE
----

 |The session acknowledges after ten messages have been consumed and
does not guarantee that messages are delivered and consumed only once.

a|
[source,oac_no_warn]
----
MQ_SESSION_TRANSACTED
----

 |This value is read only. It is set by the library if you have passed
`MQ_TRUE` for the `isTransacted` parameter to the `MQCreateSession`
function. It is returned to you by the `MQGetAcknowledgeMode` function
if the session is transacted.
|=======================================================================


[[aeldm]][[GMCCG00335]][[callback-type-for-asynchronous-message-consumption]]

Callback Type for Asynchronous Message Consumption
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When you call the link:#aeldw[MQCreateAsyncMessageConsumer] function or
the link:#aeldv[MQCreateAsyncDurableMessageConsumer] function, you must
pass the name of an `MQMessageListenerFunc` type callback function that
is to be called when the consumer receives a message to the specified
destination.

The `MQMessageListenerFunc` type has the following definition:

[source,oac_no_warn]
----
MQError (* MQMessageListenerFunc)(
                const MQSessionHandle  sessionHandle,
                const MQConsumerHandle  consumerHandle,
                MQMessageHandle  messageHandle
                void * callbackData);
----

[[ghesl]][[GMCCG00087]][[parameters]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. The client
  runtime specifies this handle when it calls your message listener.
`consumerHandle`::
  A handle to the consumer receiving the message. The client runtime
  specifies this handle when it calls your message listener.
`messageHandle`::
  A handle to the incoming message. The client runtime specifies this
  handle when it calls your message listener.
`callbackData`::
  The void pointer that you passed to the function
  link:#aeldw[MQCreateAsyncMessageConsumer] or the function
  link:#aeldv[MQCreateAsyncDurableMessageConsumer].

The body of a message listener function is written by the receiving
client. Mainly, the function needs to process the incoming message by
examining its header, body, and properties. The client is also
responsible for freeing the message handle (either from within the
handler or from outside the handler) by calling
link:#aelem[MQFreeMessage].

In addition, you should observe the following guidelines when writing
the message listener function:

* If you specify `MQ_CLIENT_ACKNOWLEDGE` as the acknowledge mode for the
session, you must explicitly call the `MQAcknowledgeMessages` function
to acknowledge messages that you have received. For more information,
see the description of the function link:#aeldp[MQAcknowledgeMessages].
* Do not try to close the session (or the connection to which it
belongs) and consumer handle in the message listener.
* It is possible for a message listener to return an error; however,
this is considered a client programming error. If the listener discovers
that the message is badly formatted or if it cannot process it for some
other reason, it should handle the problem itself by re-directing it to
an application-specific bad-message destination and process it later. +
If the message listener does return an error, the client runtime will
try to redeliver the message once if the session's acknowledge mode is
either `MQ_AUTO_ACKNOWLEDGE` or `MQ_DUPS_OK_ACKNOWLEDGE` .

[[aelgr]][[GMCCG00336]][[callback-type-for-asynchronous-message-consumption-in-distributed-transactions]]

Callback Type for Asynchronous Message Consumption in Distributed
Transactions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`MQMessageListenerBAFunc` is the type of the callback functions of
before/after `MQMessageListenerFunc` for asynchronous message receiving
from a distributed transaction session.

The `MQMessageListenerBAFunc` type has the following definition:

[source,oac_no_warn]
----
MQError (* MQMessageListenerBAFunc)(
                const MQSessionHandle  sessionHandle,
                const MQConsumerHandle  consumerHandle,
                MQMessageHandle  messageHandle
                MQError  errorCode
                void * callbackData);
----

[[gbmhc]][[GMCCG00088]][[parameters-1]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. The client
  runtime specifies this handle when it calls your message listener.
`consumerHandle`::
  A handle to the consumer receiving the message. The client runtime
  specifies this handle when it calls your message listener.
`messageHandle`::
  A handle to the incoming message. The client runtime specifies this
  handle when it calls your message listener.
`errorCode`::
  Client runtime processing status that is passed to the before/after
  callback functions.
`callbackData`::
  The void pointer that is passed to the function
  link:#aeldw[MQCreateAsyncMessageConsumer].


[NOTE]
===========================================================

What additional information is needed for his function type?

===========================================================


[[aeldn]][[GMCCG00337]][[callback-type-for-connection-exception-handling]]

Callback Type for Connection Exception Handling
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The client runtime will call this function when a connection exception
occurs.

The `MQConnectionExceptionListenerFunc` type has the following
definition:

[source,oac_no_warn]
----
Void (* MQConnectionExceptionListenerFunc)(
                const MQConnectionHandle connectionHandle,
                MQStatus exception,
                void * callbackData);
----

[[ghesx]][[GMCCG00089]][[parameters-2]]

Parameters
++++++++++

`connectionHandle`::
  The handle to the connection on which the connection exception
  occurred. The client runtime sets this handle when it calls the
  connection exception handler.
`exception`::
  An `MQStatus` for the connection exception that occurred. The client
  runtime specifies this value when it calls the exception handler. +
  You can pass this status result to any functions used to handle errors
  to get an error code or error string. For more information, see
  link:using-the-c-api.html#aelcm[Error Handling].
`callbackData`::
  Whatever void pointer was passed as the `listenerCallbackData`
  parameter to the functionlink:#aeldy[MQCreateConnection] for more
  information.

The body of a connection exception listener function is written by the
client. This function will only be called synchronously with respect to
a single connection. If you install it as the connection exception
listener for multiple connections, then it must be reentrant.

Do not try to close the session (or the connection to which it belongs)
in the exception listener.

[[aeldo]][[GMCCG00057]][[function-reference]]

Function Reference
~~~~~~~~~~~~~~~~~~

This section describes the C-API functions in alphabetical order.
link:#aeldo[Function Reference] lists the C-API functions.

[[GMCCG444]][[sthref28]][[gblza]]


Table 4-4 Message Queue C-API Function Summary

[width="100%",cols="47%,53%",options="header",]
|=======================================================================
|Function |Description
a|
link:#aeldp[MQAcknowledgeMessages]


 |Acknowledges the specified message and all messages received before it
on the same session.

a|
link:#aeldq[MQCloseConnection]


 |Closes the specified connection.

a|
link:#aeldr[MQCloseMessageConsumer]


 |Closes the specified consumer.

a|
link:#aelds[MQCloseMessageProducer]


 |Closes the specified message producer without closing its connection.

a|
link:#aeldt[MQCloseSession]


 |Closes the specified session.

a|
link:#aeldu[MQCommitSession]


 |Commits a transaction associated with the specified session.

a|
link:#aeldv[MQCreateAsyncDurableMessageConsumer]


 |Creates a durable asynchronous message consumer for the specified
destination.

a|
link:#aeldw[MQCreateAsyncMessageConsumer]


 |Creates an asynchronous message consumer for the specified
destination.

a|
link:#CIAIAGFJ[MQCreateAsyncSharedDurableMessageConsumer]


 |Creates a shared durable asynchronous message consumer for the
specified destination.

a|
link:#CIACEAJE[MQCreateAsyncSharedMessageConsumer]


 |Creates a shared asyncrhronous consumer for the specified destination.

a|
link:#aeldx[MQCreateBytesMessage]


 |Creates an `MQ_BYTES_MESSAGE` message.

a|
link:#aeldy[MQCreateConnection]


 |Creates a connection to the broker.

a|
link:#aeleb[MQCreateDestination]


 |Creates a logical destination and passes a handle to it back to you.

a|
link:#aelec[MQCreateDurableMessageConsumer]


 |Creates a durable synchronous message consumer for the specified
destination.

a|
link:#gbjak[MQCreateMessage]


 |Creates an `MQ_MESSAGE` message.

a|
link:#aeled[MQCreateMessageConsumer]


 |Creates a synchronous message consumer for the specified destination.

a|
link:#aelee[MQCreateMessageProducer]


 |Creates a message producer with no default destination.

a|
link:#aelef[MQCreateMessageProducerForDestination]


 |Creates a message producer with a default destination.

a|
link:#aeleg[MQCreateProperties]


 |Creates a properties handle.

a|
link:#aeleh[MQCreateSession]


 |Creates a session and passes back a handle to the session.

a|
link:#CIACFJDI[MQCreateSharedDurableMessageConsumer]


 |Creates a shared durable synchronous message consumer for the
specified destination.

a|
link:#CIAJABFE[MQCreateSharedMessageConsumer]


 |Creates a shared synchronous message consumer for the specified
destination.

a|
link:#aelei[MQCreateTemporaryDestination]


 |Creates a temporary destination and passes its handle back to you.

a|
link:#aelej[MQCreateTextMessage]


 |Creates a text message.

a|
link:#ghern[MQCreateXASession]


 |Creates a distributed transaction (XA) session.

a|
link:#aelek[MQFreeConnection]


 |Releases memory assigned to the specified connection and to all
resources associated with that connection.

a|
link:#aelel[MQFreeDestination]


 |Releases memory assigned to the specified destination and to all
resources associated with that destination.

a|
link:#aelem[MQFreeMessage]


 |Releases memory assigned to the specified message.

a|
link:#aelen[MQFreeProperties]


 |Releases the memory allocated to the referenced properties handle.

a|
link:#aeleo[MQFreeString]


 |Releases the memory allocated to the specified `MQString`.

a|
link:#aelep[MQGetAcknowledgeMode]


 |Passes back the acknowledgement mode of the specified session.

a|
link:#aeleq[MQGetBoolProperty]


 |Passes back a property of type `MQBool`.

a|
link:#aeler[MQGetBytesMessageBytes]


 |Passes back the address and size of a `MQ_BYTES_MESSAGE` message body.

a|
link:#ghevs[MQGetConnectionProperties]


 |Passes back a handle to the properties used in creating the connection
associated with the specified connection handle.

a|
link:#gbjog[MQGetDestinationName]


 |Passes back the name of the physical destination to which the
specified message has been sent.

a|
link:#CIAFJBHF[MQGetDeliveryDelay]


 |Passes back the delivery delay for messages sent by a producer.

a|
link:#aeles[MQGetDestinationType]


 |Passes back the type of the specified destination.

a|
link:#aelet[MQGetErrorTrace]


 |Returns a string describing the stack at the time the specified error
occurred.

a|
link:#aeleu[MQGetFloat32Property]


 |Passes back the value of the `MQFloat32` property for the specified
key.

a|
link:#aelev[MQGetFloat64Property]


 |Passes back the value of the `MQFloat64` property for the specified
key.

a|
link:#aelew[MQGetInt16Property]


 |Passes back the value of the `MQInt16` property for the specified key.

a|
link:#aelex[MQGetInt32Property]


 |Passes back the value of the `MQInt32` property for the specified key.

a|
link:#aeley[MQGetInt64Property]


 |Passes back the value of the `MQInt64` property for the specified key.

a|
link:#aelez[MQGetInt8Property]


 |Passes back the value of the `MQInt8` property for the specified key.

a|
link:#aelfa[MQGetMessageHeaders]


 |Passes back a handle to the header of the specified message.

a|
link:#aelfb[MQGetMessageProperties]


 |Passes back a handle to the properties for the specified message.

a|
link:#aelfc[MQGetMessageReplyTo]


 |Passes back the destination where replies to this message should be
sent.

a|
link:#aelfd[MQGetMessageType]


 |Passes back the type of the specified message.

a|
link:#aelfe[MQGetMetaData]


 |Passes back Message Queue version information.

a|
link:#aelff[MQGetPropertyType]


 |Passes back the type of the specified property key.

a|
link:#aelfg[MQGetStatusCode]


 |Returns the code for the specified `MQStatus` result.

a|
link:#aelfh[MQGetStatusString]


 |Returns a string description for the specified `MQStatus` result.

a|
link:#aelfi[MQGetStringProperty]


 |Passes back the value for the specified property. Type (in the
function name) can be `String`, `Bool`, `Int8`, `Int16`, `Int32`,
`Int64` , `Float32`, `Float64`.

a|
link:#aelfj[MQGetTextMessageText]


 |Passes back the contents of an `MQ_TEXT_MESSAGE` message.

a|
link:#gherz[MQGetXAConnection]


 |Passes back the distributed transaction (XA) connection.

a|
link:#aelfk[MQInitializeSSL]


 |Initializes the SSL library. You must call this function before you
create a connection that uses SSL.

a|
link:#aelfl[MQPropertiesKeyIterationGetNext]


 |Passes back the next property key in the properties handle.

a|
link:#aelfm[MQPropertiesKeyIterationHasNext]


 |Returns true if there is another property key in a properties object.

a|
link:#aelfn[MQPropertiesKeyIterationStart]


 |Starts iterating through a properties object.

a|
link:#aelfo[MQReceiveMessageNoWait]


 |Passes back a handle to a message delivered to the specified consumer.

a|
link:#aelfp[MQReceiveMessageWait]


 |Passes back a handle to a message delivered to the specified consumer
when the message becomes available.

a|
link:#aelfq[MQReceiveMessageWithTimeout]


 |Passes back a handle to a message delivered to the specified consumer
if a message is available within the specified amount of time.

a|
link:#aelfr[MQRecoverSession]


 |Stops message delivery and restarts message delivery with the oldest
unacknowledged message.

a|
link:#aelfs[MQRollBackSession]


 |Rolls back a transaction associated with the specified session.

a|
link:#aelft[MQSendMessage]


 |Sends a message for the specified producer.

a|
link:#aelfu[MQSendMessageExt]


 |Sends a message for the specified producer and allows you to set
priority, time-to-live, and delivery mode.

a|
link:#aelfv[MQSendMessageToDestination]


 |Sends a message to the specified destination.

a|
link:#aelfw[MQSendMessageToDestinationExt]


 |Sends a message to the specified destination and allows you to set
message header properties.

a|
link:#aelfx[MQSetBoolProperty]


 |Sets an `MQBool` property with the specified key to the specified
value.

a|
link:#aelfy[MQSetBytesMessageBytes]


 |Sets the message body for the specified `MQ_BYTES_MESSAGE` message.

a|
link:#CIAHJGHF[MQSetDeliveryDelay]


 |Sets the delivery delay for messages sent by the specifed JMS
producer.

a|
link:#aelfz[MQSetFloat32Property]


 |Sets an `MQFloat` 32 property with the specified key to the specified
value.

a|
link:#aelga[MQSetFloat64Property]


 |Sets an `MQFloat` 64 property with the specified key to the specified
value.

a|
link:#aelgb[MQSetInt16Property]


 |Sets an `MQInt16` property with the specified key to the specified
value.

a|
link:#aelgc[MQSetInt32Property]


 |Sets an `MQInt` 32 property with the specified key to the specified
value.

a|
link:#aelgd[MQSetInt64Property]


 |Sets an `MQInt64` property with the specified key to the specified
value.

a|
link:#aelge[MQSetInt8Property]


 |Sets an `MQInt8` property with the specified key to the specified
value.

a|
link:#aelgf[MQSetMessageHeaders]


 |Sets the header part of the message.

a|
link:#aelgg[MQSetMessageProperties]


 |Sets the user-defined properties for the specified message.

a|
link:#aelgh[MQSetMessageReplyTo]


 |Specifies the destination where replies to this message should be
sent.

a|
link:#aelgi[MQSetStringProperty]


 |Sets an `MQString` property with the specified key to the specified
value.

a|
link:#aelgi[MQSetStringProperty]


 |Sets the message body for the specified `MQ_TEXT_MESSAGE` message.

a|
link:#aelgj[MQSetTextMessageText]


 |Defines the body for a text message.

a|
link:#aelgk[MQStartConnection]


 |Starts the specified connection to the broker and starts or resumes
message delivery.

a|
link:#aelgl[MQStatusIsError]


 |Returns `MQ_TRUE` if the specified `MQStatus` result is an error.

a|
link:#aelgm[MQStopConnection]


 |Stops the specified connection to the broker. This stops the broker
from delivering messages.

a|
link:#aelgn[MQUnsubscribeDurableMessageConsumer]


 |Unsubscribes the specified durable message consumer.
|=======================================================================


[[aeldp]][[GMCCG00338]][[mqacknowledgemessages]]

MQAcknowledgeMessages
^^^^^^^^^^^^^^^^^^^^^

The `MQAcknowledgeMessages` function acknowledges the specified message
and all messages received before it on the same session. This function
is valid only if the session is created with acknowledge mode set to
`MQ_CLIENT_ACKNOWLEDGE` .

[source,oac_no_warn]
----
MQAcknowledgeMessages  (const MQSessionHandle  sessionHandle,
                              const MQMessageHandle messageHandle);
----

[[gblzk]][[GMCCG00090]][[return-value]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gblzr]][[GMCCG00091]][[parameters-3]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session for the consumer that received the specified
  message.
`messageHandle`::
  A handle to the message that you want to acknowledge. This handle is
  passed back to you when you receive the message (either by calling one
  of the receive functions or when a message is delivered to your
  message listener function.)

Whether you receive messages synchronously or asynchronously, you can
call the `MQAcknowledgeMessages` function to acknowledge receipt of the
specified message and of all messages that preceded it.

When you create a session you specify one of several acknowledge modes
for that session; these are described in link:#gblzy[Table 4-3]. If you
specify `MQ_CLIENT_ACKNOWLEDGE` as the acknowledge mode for the session,
you must explicitly call the `MQAcknowledgeMessages` function to
acknowledge receipt of messages consumed in that session.

By default, the calling thread to the `MQAcknowledgeMessages` function
will be blocked until the broker acknowledges receipt of the
acknowledgment for the broker consumed. If, when you created the
session's connection, you specified the property
`MQ_ACK_ON_ACKNOWLEDGE_PROPERTY` to be `MQ_FALSE,` the calling thread
will not wait for the broker to acknowledge the acknowledgement.

[[gblze]][[GMCCG00092]][[common-errors]]

Common Errors
+++++++++++++

`MQ_SESSION_NOT_CLIENT_ACK_MODE` +
`MQ_SESSION_NOT_CLIENT_ACK_MODE` +
`MQ_MESSAGE_NOT_IN_SESSION` +
`MQ_CONCURRENT_ACCESS` +
`MQ_SESSION_CLOSED` +
`MQ_BROKER_CLOSED`

[[aeldq]][[GMCCG00339]][[mqcloseconnection]]

MQCloseConnection
^^^^^^^^^^^^^^^^^

The `MQCloseConnection` function closes the connection to the broker.

[source,oac_no_warn]
----
MQCloseConnection(MQConnectionHandle connectionHandle);
----

[[gblzl]][[GMCCG00093]][[return-value-1]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gblzh]][[GMCCG00094]][[parameters-4]]

Parameters
++++++++++

`connectionHandle`::
  The handle to the connection that you want to close. This handle is
  created and passed back to you by the function
  link:#aeldy[MQCreateConnection].

Closing the connection closes all sessions, producers, and consumers
created from this connection. This also forces all threads associated
with this connection that are blocking in the library to return.

Closing the connection does not actually release all the memory
associated with the connection. After all the application threads
associated with this connection (and its dependent sessions, producers,
and consumers) have returned, you should call the
link:#aelek[MQFreeConnection] function to release these resources.
However, `MQFreeConnection ()` does not release resources held by a
message or a destination associated with this connection. You must free
memory allocated for a message or a destination by explicitly calling
the `MQFreeMessage` or the `MQFreeDestination` function.

[[gblzt]][[GMCCG00095]][[common-errors-1]]

Common Errors
+++++++++++++

`MQ_CONCURRENT_DEADLOCK` (If the function is called from an exception
listener or a consumer's message listener.)

`MQ_ILLEGAL_CLOSE_XA_CONNECTION` (If called to claose an XA connection.)

[[aeldr]][[GMCCG00340]][[mqclosemessageconsumer]]

MQCloseMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^

The `MQCloseMessageConsumer` function closes the specified message
consumer.

[source,oac_no_warn]
----
MQCloseMessageConsumer(MQConsumerHandle consumerHandle);
----

[[gblyz]][[GMCCG00096]][[return-value-2]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gblzi]][[GMCCG00097]][[parameters-5]]

Parameters
++++++++++

`consumerHandle`::
  The handle to the consumer you want to close. This handle is created
  and passed back to you by one of the functions used to create
  consumers. +
  This handle is invalid after the function returns successfully.

A session's consumers are automatically closed when you close the
session or connection to which they belong. To close a consumer without
closing the session or connection to which it belongs, use the
functionlink:#aeldr[MQCloseMessageConsumer].

If the consumer you want to close is a durable consumer and you want to
close this consumer permanently, you should call the function
link:#aelgn[MQUnsubscribeDurableMessageConsumer] after closing the
consumer in order to delete any state information maintained by the
broker for this consumer.

[[gblzd]][[GMCCG00098]][[common-errors-2]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_CONSUMER_NOT_IN_SESSION
MQ_BROKER_CONNECTION_CLOSED
----

[[aelds]][[GMCCG00341]][[mqclosemessageproducer]]

MQCloseMessageProducer
^^^^^^^^^^^^^^^^^^^^^^

The `MQCloseMessageProducer` function closes a message producer.

[source,oac_no_warn]
----
MQCloseMessageProducer(MQProducerHandle producerHandle);
----

[[gblzw]][[GMCCG00099]][[return-value-3]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gblzj]][[GMCCG00100]][[parameters-6]]

Parameters
++++++++++

`producerHandle`::
  A handle for this producer that was passed to you by the
  functionlink:#aelee[MQCreateMessageProducer] or by the function
  link:#aelef[MQCreateMessageProducerForDestination]. +
  This handle is invalid after the function returns successfully.

Use the `MQCloseMessageProducer` function to close a producer without
closing its associated session or connection.

[[gblzq]][[GMCCG00101]][[common-errors-3]]

Common Errors
+++++++++++++

`MQ_PRODUCER_NOT_IN_SESSION`

[[aeldt]][[GMCCG00342]][[mqclosesession]]

MQCloseSession
^^^^^^^^^^^^^^

The `MQCloseSession` function closes the specified session.

[source,oac_no_warn]
----
MQCloseSession(MQSessionHandle sessionHandle);
----

[[gblzg]][[GMCCG00102]][[return-value-4]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gblzf]][[GMCCG00103]][[parameters-7]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session that you want to close. This handle is
  created and passed back to you by the link:#aeleh[MQCreateSession]
  function. +
  This handle is invalid after the function returns successfully.

Closing a session closes the resources (producers and consumers)
associated with that session and frees up the memory allocated for that
session.

Calling this function does not release resources held by a message or a
destination associated with this session. You must free memory allocated
for a message or a destination by explicitly calling the `MQFreeMessage`
or the `MQFreeDestination` function.

There is no need to close the producers or consumers of a closed
session.

[[gblzo]][[GMCCG00104]][[common-errors-4]]

Common Errors
+++++++++++++

`MQ_CONCURRENT_DEADLOCK`

(If called from a consumer's message listener in the session.)

[[aeldu]][[GMCCG00343]][[mqcommitsession]]

MQCommitSession
^^^^^^^^^^^^^^^

The `MQCommitSession` function commits a transaction associated with the
specified session.

[source,oac_no_warn]
----
MQCommitSession(const MQSessionHandle sessionHandle);
----

[[gblzs]][[GMCCG00105]][[return-value-5]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gblyy]][[GMCCG00106]][[parameters-8]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the transacted session that you want to commit.

A transacted session supports a series of transactions. Transactions
organize a session's input message stream and output message stream into
a series of atomic units. A transaction's input and output units consist
of those messages that have been produced and consumed within the
session's current transaction. (Note that the receipt of a message
cannot be part of the same transaction that produces the message.) When
you call the `MQCommitSession` function, its atomic unit of input is
acknowledged and its associated atomic unit of output is sent.

The completion of a session's current transaction automatically begins
the next transaction. The result is that a transacted session always has
a current transaction within which its work is done. Use the
`MQRollBackSession ()` function to roll back a transaction.

[[gblzx]][[GMCCG00107]][[common-errors-5]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_TRANSACTED_SESSION
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_NOT_TRANSACTED_SESSION
MQ_XA_SESSION_IN_PROGRESS
----

[[aeldv]][[GMCCG00344]][[mqcreateasyncdurablemessageconsumer]]

MQCreateAsyncDurableMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateAsyncDurableMessageConsumer` function creates an
asynchronous durable message consumer for the specified destination.

[source,oac_no_warn]
----
MQCreateAsyncDurableMessageConsumer (
               const MQSessionHandle sessionHandle,
               const MQDestinationHandle destinationHandle,
               ConstMQString durableName,
               ConstMQString messageSelector,
               MQBool noLocal,
               MQMessageListenerFunc messageListener,
               void * listenerCallbackData,
               MQConsumerHandle * consumerHandle);
----

[[gblzm]][[GMCCG00108]][[return-value-6]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmac]][[GMCCG00109]][[parameters-9]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is passed back by the link:#aeleh[MQCreateSession] function. For this
  asynchronous durable consumer, the session must have been created with
  the `MQ_SESSION_ASYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to a topic destination on which the consumer receives
  messages. This handle remains valid after the call.
`durableName`::
  An `MQString` specifying a name for the durable subscriber. The
  library makes a copy of the `durableName` string.
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. +
  Specify a `NULL` or empty string to indicate that there is no message
  selector for this consumer. In this case, all messages are delivered. +
  The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`noLocal`::
  Specify `MQ_TRUE` to inhibit delivery of messages published by this
  consumer's own connection.
`messageListener`::
  The name of an `MQMessageListenerFunc` type callback function that is
  to be called when this consumer receives a message on the specified
  destination.
`listenerCallbackData`::
  A pointer to data that you want passed to your message listener
  function when it is called by the library.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

In the case of an asynchronous consumer, you should not start a
connection before calling the `MQCreateAsyncDurableMessageConsumer`
function. (You should create a connection, create a session, set up your
asynchronous consumer, create the consumer, and then start the
connection.) Attempting to create a consumer when the connection is not
stopped, will result in an `MQ_CONCURRENT_ACCESS` error.

The `MQCreateAsyncDurableMessageConsumer` function creates an
asynchronous durable message consumer for the specified destination. You
can define parameters to filter messages and to inhibit the delivery of
messages you published to your own connection. Note that the session's
receive mode (sync/async) must be appropriate for the kind of consumer
you are creating (sync/async). To create a synchronous durable message
consumer for a destination, call the function
`MQCreateDurableMessageConsumer.()`

Durable consumers can only be used for topic destinations. If you are
creating an asynchronous consumer for a queue destination or if you are
not interested in messages that arrive to a topic while you are
inactive, you might prefer to use the function
link:#aeldw[MQCreateAsyncMessageConsumer].

The broker retains a record of this durable subscription and makes sure
that all messages from the publishers to this topic are retained until
they are either acknowledged by this durable subscriber or until they
have expired. Sessions with durable subscribers must always provide the
same client identifier. (See `MQCreateConnection`, `clientID`
parameter.) In addition, each durable consumer must specify a durable
name using the `durableName` parameter, which uniquely identifies (for
each client identifier) the durable subscription when it is created.

A session's consumers are automatically closed when you close the
session or connection to which they belong. However, messages will be
routed to the durable subscriber while it is inactive and delivered when
the durable consumer is recreated. To close a consumer without closing
the session or connection to which it belongs, use the
link:#aeldr[MQCloseMessageConsumer] function. If you want to close a
durable consumer permanently, you should call the
link:#aelgn[MQUnsubscribeDurableMessageConsumer] after closing it to
delete state information maintained by the Broker on behalf of the
durable consumer.

[[gbmab]][[GMCCG00110]][[common-errors-6]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_ASYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMIT_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONSUMER_NO_DURABLE_NAME
MQ_QUEUE_CONSUMER_CANNOT_BE_DURABLE
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
----

[[aeldw]][[GMCCG00345]][[mqcreateasyncmessageconsumer]]

MQCreateAsyncMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateAsyncMessageConsumer` function creates an asynchronous
message consumer for the specified destination.

[source,oac_no_warn]
----
MQCreateAsyncMessageConsumer
              (const MQSessionHandle sessionHandle,
               const MQDestinationHandle destinationHandle,
               ConstMQString messageSelector,
               MQBool noLocal,
               MQMessageListenerFunc messageListener,
               void * listenerCallBackData,
               MQConsumerHandle * consumerHandle);
----

[[gbmax]][[GMCCG00111]][[return-value-7]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbb]][[GMCCG00112]][[parameters-10]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is created and passed back to you by the link:#aeleh[MQCreateSession]
  function. For this asynchronous consumer, the session must have been
  created with the `MQ_SESSION_ASYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to the destination on which the consumer receives messages.
  This handle remains valid after the call returns.
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. +
  Specify a `NULL` or empty string to indicate that there is no message
  selector for this consumer. In this case, all messages will be
  delivered. +
  The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`noLocal`::
  Specify `MQ_TRUE` to inhibit delivery of messages published by this
  consumer's own connection. +
  The setting of this parameter applies only to topic destinations. It
  is ignored for queues.
`messageListener`::
  The name of an `MQMessageListenerFunc` type callback function that is
  to be called when this consumer receives a message for the specified
  destination.
`listenerCallbackData`::
  A pointer to data that you want passed to your message listener
  function when it is called by the library.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

In the case of an asynchronous consumer, you should not start a
connection before calling the `MQCreateAsyncDurableMessageConsumer`
function. (You should create a connection, create a session, set up your
asynchronous consumers, create the consumer, and then start the
connection.) Attempting to create a consumer when the connection is not
stopped will result in an `MQ_CONCURRENT_ACCESS` error.

The `MQCreateAsyncMessageConsumer` function creates an asynchronous
message consumer for the specified destination. You can define
parameters to filter messages and to inhibit the delivery of messages
you published to your own connection. Note that the session's receive
mode (sync/async) must be appropriate for the kind of consumer you are
creating (sync/async). To create a synchronous message consumer for a
destination, use the link:#aeled[MQCreateMessageConsumer] function.

If this consumer is on a topic destination, it will only receive
messages produced while the consumer is active. If you are interested in
receiving messages published while this consumer is not active, you
should create a consumer using the
link:#aeldv[MQCreateAsyncDurableMessageConsumer] function instead.

A session's consumers are automatically closed when you close the
session or connection to which they belong. To close a consumer without
closing the session or connection to which it belongs, use the
link:#aeldr[MQCloseMessageConsumer] function.

[[gbmaq]][[GMCCG00113]][[common-errors-7]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_ASYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMIT_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
----

[[CIAIAGFJ]][[GMCCG445]][[mqcreateasyncshareddurablemessageconsumer]]

MQCreateAsyncSharedDurableMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateAsyncSharedDurableMessageConsumer` function creates an
asynchronous shared durable subscription with the specified name (if one
does not already exist) and creates a consumer on that durable
subscription for the specified topic destination.

[source,oac_no_warn]
----
MQCreateAsyncSharedDurableMessageConsumer (
               const MQSessionHandle sessionHandle,
               const MQDestinationHandle destinationHandle,
               ConstMQString durableName,
               ConstMQString messageSelector,
               MQMessageListenerFunc messageListener,
               void * listenerCallbackData,
               MQConsumerHandle * consumerHandle);
----

[[GMCCG446]][[sthref29]]


[[return-value-8]]
Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[GMCCG447]][[sthref30]]


[[parameters-11]]
Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is passed back by the `MQCreateSession()` function. For this
  asynchronous durable consumer, the session must have been created with
  the `MQ_SESSION_ASYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to a topic destination on which the consumer receives
  messages. This handle remains valid after the call.
`durableName`::
  An `MQString` specifying a name to identify this durable subscription.
  The library makes a copy of the `durableName` string..
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. +
  Specify a `NULL` or empty string to indicate that there is no message
  selector for this consumer. In this case, all messages are delivered. +
  The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`messageListener`::
  The name of an `MQMessageListenerFunc` type callback function that is
  to be called when this consumer receives a message on the specified
  destination.
`listenerCallbackData`::
  A pointer to data that you want passed to your message listener
  function when it is called by the library.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

In the case of an asynchronous consumer, you should not start a
connection before calling the
`MQCreateAsyncSharedDurableMessageConsumer` function. (You should create
a connection, create a session, set up your asynchronous consumer,
create the consumer, and then start the connection.) Attempting to
create a consumer when the connection is not stopped, will result in an
`MQ_CONCURRENT_ACCESS` error.

You can define parameters to filter messages. The session's receive mode
(sync/async) must be appropriate for the kind of consumer you are
creating (sync/async). To create a synchronous shared durable message
consumer for a topic destination, call the function
`MQCreateSharedDurableMessageConsumer()`. To create an unshared
asynchronous durable message consumer, use the function
`MQCreateAsyncDurableMessageConsumer()`.

Durable consumers can only be used for topic destinations. If you are
creating an asynchronous consumer for a queue destination, use
link:#aeldw[MQCreateAsyncMessageConsumer]. If you are not interested in
messages that arrive to a topic while you are inactive, you might prefer
to use the function link:#CIACEAJE[MQCreateAsyncSharedMessageConsumer].

The broker retains a record of this durable subscription and makes sure
that all messages from the publishers to this topic are retained until
they are either acknowledged by a consumer on the durable subscription
or until they have expired. A durable subscription continues to
accumulate messages until it is deleted using the
link:#aelgn[MQUnsubscribeDurableMessageConsumer] function.

A shared subscription is used by a client which needs to be able to
share the work of receiving messages from a topic subscription amongst
multiple consumers. This means that multiple active (not closed)
consumers on the subscription may exist at the same time. A shared
durable subscription is identified by a name specified by the
`durableName` parameter and by the client identifier (which may be
unset, see the `clientId` parameter in link:#aeldy[MQCreateConnection]).

A shared durable subscription and an unshared durable subscription may
not have the same name and client identifier (if set).

There is no restriction on durable subscriptions and shared non-durable
subscriptions having the same name and `clientId` (which may be unset).
Durable subscriptions and shared non-durable subscriptions have separate
name spaces.

A session's consumers are automatically closed when you close the
session or connection to which they belong. To close a consumer without
closing the session or connection to which it belongs, use
link:#aeldr[MQCloseMessageConsumer] function. To delete the durable
subscription, use function
link:#aelgn[MQUnsubscribeDurableMessageConsumer] after all its consumers
are closed.

[[GMCCG448]][[sthref31]]


[[common-errors-8]]
Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_ASYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMIT_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONSUMER_NO_DURABLE_NAME
MQ_QUEUE_CONSUMER_CANNOT_BE_DURABLE
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_SHARED_SUBSCRIPTION_NOT_TOPIC
----

[[CIACEAJE]][[GMCCG449]][[mqcreateasyncsharedmessageconsumer]]

MQCreateAsyncSharedMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateAsyncSharedMessageConsumer` function creates an
asynchronous shared non-durable subscription with the specified name (if
one does not already exist) and creates a consumer on that non-durable
subscription for the specified topic destination.

[source,oac_no_warn]
----
MQCreateAsyncSharedMessageConsumer
              (const MQSessionHandle sessionHandle,
               const MQDestinationHandle destinationHandle,
               ConstMQString subscriptionName,
               ConstMQString messageSelector,
               MQMessageListenerFunc messageListener,
               void * listenerCallBackData,
               MQConsumerHandle * consumerHandle);
----

[[GMCCG450]][[sthref32]]


[[return-value-9]]
Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[GMCCG451]][[sthref33]]


[[parameters-12]]
Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is created and passed back to you by the link:#aeleh[MQCreateSession]
  function. For this asynchronous consumer, the session must have been
  created with the `MQ_SESSION_ASYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to the destination on which the consumer receives messages.
  This handle remains valid after the call returns.
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. +
  Specify a `NULL` or empty string to indicate that there is no message
  selector for this consumer. In this case, all messages will be
  delivered. +
  The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`messageListener`::
  The name of an `MQMessageListenerFunc` type callback function that is
  to be called when this consumer receives a message for the specified
  destination.
`listenerCallbackData`::
  A pointer to data that you want passed to your message listener
  function when it is called by the library.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

In the case of an asynchronous consumer, you should not start a
connection before calling the
link:#CIACEAJE[MQCreateAsyncSharedMessageConsumer] . (You should create
a connection, create a session, set up your asynchronous consumers,
create the consumer, and then start the connection.) Attempting to
create a consumer when the connection is not stopped will result in an
`MQ_CONCURRENT_ACCESS` error.

You can define parameters to filter messages. The session's receive mode
(sync/async) must be appropriate for the kind of consumer you are
creating (sync/async). To create a synchronous shared message consumer
for a topic destination, use the `MQCreateSharedMessageConsumer()`
function.

A non-durable shared subscription is used by a client which needs to be
able to share the work of receiving messages from a topic subscription
amongst multiple consumers. A non-durable shared subscription may
therefore have more than one consumer. Each message from the
subscription will be delivered to only one of the consumers on that
subscription. Such a subscription is not persisted and will be deleted
(together with any undelivered messages associated with it) when there
are no consumers on it.

A session's consumers are automatically closed when you close the
session or connection to which they belong. To close a consumer without
closing the session or connection to which it belongs, use the
link:#aeldr[MQCloseMessageConsumer] function.

[[GMCCG452]][[sthref34]]


[[common-errors-9]]
Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_ASYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMIT_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_SHARED_SUBSCRIPTION_NOT_TOPIC
----

[[aeldx]][[GMCCG00346]][[mqcreatebytesmessage]]

MQCreateBytesMessage
^^^^^^^^^^^^^^^^^^^^

The `MQCreatesBytesMessage` function creates a bytes message and passes
a handle to it back to you.

[source,oac_no_warn]
----
MQCreateBytesMessage(MQMessageHandle * messageHandle);
----

[[gbmad]][[GMCCG00114]][[return-value-10]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmar]][[GMCCG00115]][[parameters-13]]

Parameters
++++++++++

`messageHandle`::
  Output parameter for the handle to the new, empty message.

After you obtain the handle to a bytes message, you can use this handle
to define its content with the
link:#aelfy[MQSetBytesMessageBytes]link:#aelfy[MQSetBytesMessageBytes]
function, to set its headers with the link:#aelgf[MQSetMessageHeaders]
function, and to set its properties with the
link:#aelgg[MQSetMessageProperties] function.

[[aeldy]][[GMCCG00347]][[mqcreateconnection]]

MQCreateConnection
^^^^^^^^^^^^^^^^^^

The `MQCreateConnection` function creates a connection to the broker.

If you want to connect to the broker over SSL, you must call the
link:#aelfk[MQInitializeSSL] function to initialize the SSL library
before you create the connection.

[source,oac_no_warn]
----
MQCreateConnection
             (MQPropertiesHandle propertiesHandle
             ConstMQString username,
             ConstMQString password,
             ConstMQString clientID,
             MQConnectionExceptionListenerFunc exceptionListener,
             void * listenerCallBackData,
             MQConnectionHandle * connectionHandle);
----

[[gbmaf]][[GMCCG00116]][[return-value-11]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmai]][[GMCCG00117]][[parameters-14]]

Parameters
++++++++++

`propertiesHandle`::
  A handle that specifies the properties that determine the behavior of
  this connection. You must create this handle using the
  `MQCreateProperties` function before you try to create a connection.
  This handle will be invalid after the function returns successfully. +
  See link:#gcsrb[Table 4-2] for information about connection
  properties.
`username`::
  An `MQString` specifying the user name to use when connecting to the
  broker. +
  The library makes a copy of the `username` string.
`password`::
  An `MQString` specifying the password to use when connecting to the
  broker. +
  The library makes a copy of the `password` string.
`clientID`::
  An `MQString` used to identify the connection. If you use the
  connection for a durable consumer, you must specify a non-NULL client
  identifier. +
  The library makes a copy of the `clientID` string.
`exceptionListener`::
  A connection-exception callback function used to notify the user that
  a connection exception has occurred.
`listenerCallBackData`::
  A data pointer that can be passed to the connection
  `exceptionListener` callback function whenever it is called. The user
  can set this pointer to any data that may be useful to pass along to
  the connection exception listener for this connection. Set this to
  `NULL` if you do not need to pass data back to the connection
  exception listener.
`connectionHandle`::
  Output parameter for the handle to the connection that is created by
  this function.

The `MQCreateConnection` function creates a connection to the broker.
The behavior of the connection is specified by key values defined in the
properties referenced by the `propertiesHandle` parameter. You must use
the `MQCreateProperties` function to define these properties.

You cannot change the properties of a connection you have already
created. If you need different connection properties, you must close and
free the old connection and then create a new connection with the
desired properties.

* Use the link:#aelgk[MQStartConnection] function to start or restart
the connection. Use the link:#aelgm[MQStopConnection] function to stop a
connection.
* Use the link:#aelfe[MQGetMetaData] function to get information about
the name of the Message Queue product and its version.
* Use the link:#aeldq[MQCloseConnection] function to close a connection,
and then use the link:#aelek[MQFreeConnection] function to free the
memory allocated for that connection.

[[aeldz]][[GMCCG00011]][[setting-a-client-identifier]]

Setting a Client Identifier

To keep track of durable subscriptions, Message Queue uses a unique
client identifier that associates a client's connection with state
information maintained by the message service on behalf of the client.
By definition, a client identifier is unique, and applies to only one
connection at a time.

The messaging service uses a client identifier in combination with a
durable subscription name to uniquely identify each durable
subscription. If a durable subscriber is inactive at the time that
messages are delivered to a topic destination, the broker retains
messages for that subscriber and delivers them when the subscriber once
again becomes active.

[[aelea]][[GMCCG00012]][[handling-connection-exceptions]]

Handling Connection Exceptions

Use the `exceptionListener` parameter to pass the name of a user-defined
callback function that can be called synchronously when a connection
exception occurs for this connection. Use the `exceptionCallBackData`
parameter to specify any user data that you want to pass to the callback
function.

[[gbman]][[GMCCG00118]][[common-errors-10]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_INCOMPATIBLE_LIBRARY
MQ_CONNECTION_UNSUPPORTED_TRANSPORT
MQ_COULD_NOT_CREATE_THREAD
MQ_INVALID_CLIENT_ID
MQ_CLIENT_ID_IN_USE
MQ_COULD_NOT_CONNECT_TO_BROKER
MQ_SSL_NOT_INITIALIZED
----

This error can be returned if `MQ_CONNECTION_TYPE_PROPERTY` is SSL and
you have not called the `MQInitializeSSL` function before creating this
connection.

[[aeleb]][[GMCCG00348]][[mqcreatedestination]]

MQCreateDestination
^^^^^^^^^^^^^^^^^^^

The `MQCreateDestination` function creates a a logical destination and
passes a handle to it back to you.

[source,oac_no_warn]
----
MQCreateDestination(const MQSessionHandle sessionHandle
                 ConstMQString destinationName,
                 MQDestinationType destinationType,
                 MQDestinationHandle * destinationHandle);
----

[[gbmau]][[GMCCG00119]][[return-value-12]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmay]][[GMCCG00120]][[parameters-15]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session with which you want to associate this
  destination.
`destinationName`::
  An `MQString` specifying the logical name of this destination. The
  library makes a copy of the `destinationName` string. See discussion
  below. +
  Destination names starting with "mq" are reserved and should not be
  used by clients.
`destinationType`::
  An enum specifying the destination type, either `MQ_QUEUE_DESTINATION`
  or `MQ_TOPIC_DESTINATION`.
`destinationHandle`::
  Output parameter for the handle to the newly created destination. You
  can pass this handle to functions sending messages or to message
  producers or consumers.

The `MQCreateDestination` function creates a logical destination and
passes a handle to it back to you. Note that the Message Queue
administrator has to also create a physical destination on the broker,
whose name and type is the same as the destination created here, in
order for messaging to happen. For example, if you use this function to
create a queue destination called `myMailQDest`, the administrator has
to create a physical destination on the broker named `myMailQDest`.

If you are doing development, you can simplify this process by turning
on the `imq.autocreate.topic` or `imq.autocreate.queue` properties for
the broker. If you do this, the broker automatically creates a physical
destination whenever a message consumer or message producer attempts to
access a non-existent destination. The auto-created destination will
have the same name as the logical destination name you specified using
the `MQCreateDestination` function. By default, the broker has the
properties `imq.autocreate.topic` and `imq.autocreate.queue` turned on.

[[gbmam]][[GMCCG00121]][[common-errors-11]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_INVALID_DESTINATION_TYPE
MQ_SESSION_CLOSED
----

[[aelec]][[GMCCG00349]][[mqcreatedurablemessageconsumer]]

MQCreateDurableMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateDurableMessageConsumer` function creates a synchronous
durable message consumer for the specified topic destination.

[source,oac_no_warn]
----
MQCreateDurableMessageConsumer
          (const MQSessionHandle sessionHandle,
           const MQDestinationHandle destinationHandle,
           ConstMQString durableName,
           ConstMQString messageSelector,
           MQBool noLocal
           MQConsumerHandle * consumerHandle);
----

[[gbmag]][[GMCCG00122]][[return-value-13]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmaa]][[GMCCG00123]][[parameters-16]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is passed back to you by the link:#aeleh[MQCreateSession] function.
  For this (synchronous) durable consumer, the session must have been
  created with the `MQ_SESSION_SYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to a topic destination on which the consumer receives
  messages. This handle remains valid after the call returns.
`durableName`::
  An `MQString` specifying the name of the durable subscriber to the
  topic destination. The library makes a copy of the `durableName`
  string.
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. +
  Specify a `NULL` or empty string to indicate that there is no message
  selector for this consumer. In this case, the consumer receives all
  messages. The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`noLocal`::
  Specify `MQ_TRUE` to inhibit delivery of messages published by this
  consumer's own connection.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

The `MQCreateDurableMessageConsumer` function creates a synchronous
message consumer for the specified destination. A durable consumer
receives all the messages published to a topic, including the ones
published while the subscriber is inactive.

You can define parameters to filter messages and to inhibit the delivery
of messages you published to your own connection. Note that the
session's receive mode (sync/async) must be appropriate for the kind of
consumer you are creating (sync/async). To create an asynchronous
durable message consumer for a destination, call the function
link:#aeldv[MQCreateAsyncDurableMessageConsumer].

Durable consumers are for topic destinations. If you are creating a
consumer for a queue destination or if you are not interested in
messages that arrive to a topic while you are inactive, you should use
the function `MQCreateMessageConsumer.()`

The broker retains a record of this durable subscription and makes sure
that all messages from the publishers to this topic are retained until
they are either acknowledged by this durable subscriber or until they
have expired. Sessions with durable subscribers must always provide the
same client identifier (see `MQCreateConnection`, `clientID` parameter).
In addition, each durable consumer must specify a durable name using the
`durableName` parameter, which uniquely identifies (for each client
identifier) the durable subscription when it is created.

A session's consumers are automatically closed when you close the
session or connection to which they belong. However, messages will be
routed to the durable subscriber while it is inactive and delivered when
the durable consumer is recreated. To close a consumer without closing
the session or connection to which it belongs, use the
link:#aeldr[MQCloseMessageConsumer] function. If you want to close a
durable consumer permanently, you should call the
link:#aelgn[MQUnsubscribeDurableMessageConsumer] function after closing
it to delete state information maintained by the broker on behalf of the
durable consumer.

[[gbmav]][[GMCCG00124]][[common-errors-12]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_SYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMITE_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONSUMER_NO_DURABLE_NAME
MQ_QUEUE_CONSUMER_CANNOT_BE_DURABLE
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
----

[[gbjak]][[GMCCG00350]][[mqcreatemessage]]

MQCreateMessage
^^^^^^^^^^^^^^^

The `MQCreateMessage` function creates a new message of type
`MQ_MESSAGE`.

[source,oac_no_warn]
----
MQCreateMessage
                  (MQMessageHandle * messageHandle);
----

[[gbmat]][[GMCCG00125]][[return-value-14]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbd]][[GMCCG00126]][[parameters-17]]

Parameters
++++++++++

`messageHandle`::
  Output parameter for the handle that references the newly created
  message.

Use the `MQCreateMessage` function to create a message that has a header
and, optionally, properties, but which does not have a body. Such
messages might be used by applications to signal events, which could be
specified using header fields or message properties. This could improve
performance because the message does not have a body and therefore there
is no body to parse.

[[aeled]][[GMCCG00351]][[mqcreatemessageconsumer]]

MQCreateMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateMessageConsumer` function creates a synchronous message
consumer for the specified destination.

[source,oac_no_warn]
----
MQCreateMessageConsumer
                  (const MQSessionHandle sessionHandle,
                   const MQDestinationHandle destinationHandle,
                   ConstMQString messageSelector,
                   MQBool noLocal
                   MQConsumerHandle * consumerHandle);
----

[[gbmas]][[GMCCG00127]][[return-value-15]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmaw]][[GMCCG00128]][[parameters-18]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is passed back to you by the link:#aeleh[MQCreateSession] function.
  For this (synchronous) consumer, the session must have been created
  with the `MQ_SESSION_SYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to the destination on which the consumer receives messages.
  This handle remains valid after the call returns.
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. Specify a `NULL` or empty string to indicate that there is
  no message selector for this consumer and that all messages should be
  returned. +
  The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`noLocal`::
  Specify `MQ_TRUE` to inhibit delivery of messages published by this
  consumer's own connection. This applies only to topic destinations; it
  is ignored for queues.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

The `MQCreateMessageConsumer()` function creates a synchronous message
consumer for the specified destination. You can define parameters to
filter messages and to inhibit the delivery of messages you published to
your own connection. Note that the session's receive mode (sync/async)
must be appropriate for the kind of consumer you are creating
(sync/async). To create an asynchronous message consumer for a
destination, use the link:#aeldw[MQCreateAsyncMessageConsumer] function.

If the consumer is a topic destination, it can only receive messages
that are published while it is active. To receive messages published
while this consumer is not active, you should create a consumer using
either the link:#aelec[MQCreateDurableMessageConsumer] function or the
link:#aeldv[MQCreateAsyncDurableMessageConsumer] function, depending on
the receive mode you defined for the session.

A session's consumers are automatically closed when you close the
session or connection to which they belong. To close a consumer without
closing the session or connection to which it belongs, use the
`MQCloseMessageConsumer ()` function.

[[gbmaz]][[GMCCG00129]][[common-errors-13]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_SYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMIT_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
----

[[aelee]][[GMCCG00352]][[mqcreatemessageproducer]]

MQCreateMessageProducer
^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateMessageProducer` function creates a message producer that
does not have a specified destination.

[source,oac_no_warn]
----
MQCreateMessageProducer(const MQSessionHandle sessionHandle,
 MQProducerHandle * producerHandle);
----

[[gbmao]][[GMCCG00130]][[return-value-16]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmah]][[GMCCG00131]][[parameters-19]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this producer should belong.
`producerHandle`::
  Output parameter for the handle that references the producer.

The `MQCreateMessageProducer` function creates a message producer that
does not have a specified destination. In this case, you will specify
the destination when sending the message itself by using either the
link:#aelfv[MQSendMessageToDestination] function or the
link:#aelfw[MQSendMessageToDestinationExt] function.

Using the `MQCreateMessageProducer` function is appropriate when you
want to use the same producer to send messages to a variety of
destinations. If, on the other hand, you want to use one producer to
send many messages to the same destination, you should use the
link:#aelef[MQCreateMessageProducerForDestination] function instead.

A session's producers are automatically closed when you close the
session or connection to which they belong. To close a producer without
closing the session or connection to which it belongs, use the
link:#aelds[MQCloseMessageProducer] function.

[[gbmal]][[GMCCG00132]][[common-errors-14]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_SESSION_CLOSED
----

[[aelef]][[GMCCG00353]][[mqcreatemessageproducerfordestination]]

MQCreateMessageProducerForDestination
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateMessageProducerForDestination` function creates a message
producer with a specified destination.

[source,oac_no_warn]
----
MQCreateMessageProducerForDestination
                    (const MQSessionHandle sessionHandle,
                     const MQDestinationHandle destinationHandle,
                     MQProducerHandle * producerHandle);
----

[[gbmba]][[GMCCG00133]][[return-value-17]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmap]][[GMCCG00134]][[parameters-20]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this producer belongs.
`destinationHandle`::
  A handle to the destination where you want this producer to send all
  messages. This handle remains valid after the call returns.
`producerHandle`::
  Output parameter for the handle that references the producer.

The `MQCreateMessageProducerForDestination` function creates a message
producer with a specified destination. All messages sent out by this
producer will go to that destination. Use the link:#aelft[MQSendMessage]
function or the link:#aelfu[MQSendMessageExt] function to send messages
for a producer with a specified destination.

Use the link:#aelee[MQCreateMessageProducer] function when you want to
use one producer to send messages to a variety of destinations.

A session's producers are automatically closed when you close the
session or connection to which they belong. To close a producer without
closing the session or connection to which it belongs, use the
`MQCloseMessageProducer ()` function.

[[gbmbc]][[GMCCG00135]][[common-errors-15]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
----

[[aeleg]][[GMCCG00354]][[mqcreateproperties]]

MQCreateProperties
^^^^^^^^^^^^^^^^^^

The `MQCreateProperties` function creates a properties handle and passes
it back to the caller.

[source,oac_no_warn]
----
MQCreateProperties (MQPropertiesHandle * propertiesHandle);
----

[[gbmae]][[GMCCG00136]][[return-value-18]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmaj]][[GMCCG00137]][[parameters-21]]

Parameters
++++++++++

`propertiesHandle`::
  Output parameter for the handle that references the newly created
  properties object.

Use the `MQCreateProperties` function to get a properties handle. You
can then use the appropriate `MQSet...Property` function to set the
desired properties.

[[aeleh]][[GMCCG00355]][[mqcreatesession]]

MQCreateSession
^^^^^^^^^^^^^^^

The `MQCreateSession` function creates a session, defines its behavior,
and passes back a handle to the session.

[source,oac_no_warn]
----
MQCreateSession(const MQConnectionHandle connectionHandle,
                 MQBool isTransacted,
                 MQAckMode acknowledgeMode,
                 MQReceiveMode receiveMode
                 MQSessionHandle * sessionHandle);
----

[[gbmak]][[GMCCG00138]][[return-value-19]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbj]][[GMCCG00139]][[parameters-22]]

Parameters
++++++++++

`connectionHandle`::
  The handle to the connection to which this session belongs. This
  handle is passed back to you by the link:#aeldy[MQCreateConnection]
  function. You can create multiple sessions on a single connection.
`isTransacted`::
  An `MQBool` specifying whether this session is transacted. Specify
  `MQ_TRUE` if the session is transacted. In this case, the
  `acknowledgeMode` parameter is ignored.
`acknowledgeMode`::
  An enumeration of the possible kinds of acknowledgement modes for the
  session. See link:#aeldl[Acknowledge Modes] for information on these
  values. +
  After you have created a session, you can determine its
  acknowledgement mode by calling the link:#aelep[MQGetAcknowledgeMode]
  function.
`receiveMode`::
  An enumeration specifying whether this session will do synchronous or
  asynchronous message receives. Specify `MQ_SESSION_SYNC_RECEIVE` or
  `MQ_SESSION_ASYNC_RECEIVE`. +
  If the session is only for producing messages, the `receiveMode` has
  no significance. In that case, specify `MQ_SESSION_SYNC_RECEIVE` to
  optimize the session's resource use.
`sessionHandle`::
  A handle to this session. You will need to pass this handle to the
  functions you use to manage the session and to create destinations,
  consumers, and producers associated with this session.

The `MQCreateSession` function creates a new session and passes back a
handle to it in the `sessionHandle` parameter. The number of sessions
you can create for a single connection is limited only by system
resources. A session is a single-thread context for producing and
consuming messages. You can create multiple producers and consumers for
a session, but you are restricted to use them serially. In effect, only
a single logical thread of control can use them.

A session with a registered message listener is dedicated to the thread
of control that delivers messages to the listener. This means that if
you want to send messages, for example, you must create another session
with which to do this. The only operations you can perform on a session
with a registered listener, is to close the session or the connection.

After you create a session, you can create the producers, consumers, and
destinations that use the session context to do their work.

* For a session that is not transacted, use the
link:#aelfr[MQRecoverSession] function to restart message delivery with
the last unacknowledged message.
* For a session that is transacted, use the
link:#aelfs[MQRollBackSession] function to roll back any messages that
were delivered within this transaction. Use the
link:#aeldu[MQCommitSession] function to commit all messages associated
with this transaction.
* For a session that has `acknowledgeMode` set to
`MQ_CLIENT_ACKNOWLEDGE`, use the function
link:#aeldp[MQAcknowledgeMessages] to acknowledge consumed messages.
* Use the link:#aeldt[MQCloseSession] function to close a session and
all its associated producers and consumers. This function also frees
memory allocated for the session.

[[CIACFJDI]][[GMCCG453]][[mqcreateshareddurablemessageconsumer]]

MQCreateSharedDurableMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateSharedDurableMessageConsumer` function creates a
synchronous shared durable subscription with the specified name (if one
does not already exist) and creates a consumer on that durable
subscription for the specified topic destination.

[source,oac_no_warn]
----
MQCreateSharedDurableMessageConsumer
          (const MQSessionHandle sessionHandle,
           const MQDestinationHandle destinationHandle,
           ConstMQString durableName,
           ConstMQString messageSelector,
           MQConsumerHandle * consumerHandle);
----

[[GMCCG454]][[sthref35]]


[[return-value-20]]
Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[GMCCG455]][[sthref36]]


[[parameters-23]]
Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is passed back to you by the link:#aeleh[MQCreateSession] function.
  For this (synchronous) durable consumer, the session must have been
  created with the `MQ_SESSION_SYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to a topic destination on which the consumer receives
  messages. This handle remains valid after the call returns.
`durableName`::
  An `MQString` specifying the name of the durable subscriber to the
  topic destination. The library makes a copy of the `durableName`
  string.
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. +
  Specify a `NULL` or empty string to indicate that there is no message
  selector for this consumer. In this case, the consumer receives all
  messages. The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

You can define parameters to filter messages. The session's receive mode
(sync/async) must be appropriate for the kind of consumer you are
creating (sync/async). To create an asynchronous shared durable message
consumer for a topic destination, call the function
`MQCreateSyncSharedDurableMessageConsumer()`. To create an unshared
synchronous durable message consumer, use the function
`MQCreateDurableMessageConsumer()`.

Durable consumers can only be used for topic destinations. If you are
creating a synchronous consumer for a queue destination, use function
link:#aeled[MQCreateMessageConsumer]. If you are not interested in
messages that arrive to a topic while you are inactive, you might prefer
to use the function link:#CIAJABFE[MQCreateSharedMessageConsumer].

The broker retains a record of this durable subscription and makes sure
that all messages from the publishers to this topic are retained until
they are either acknowledged by a consumer on the durable subscription
or until they have expired. A durable subscription continues to
accumulate messages until it is deleted using the
link:#aelgn[MQUnsubscribeDurableMessageConsumer] function.

A shared subscription is used by a client which needs to be able to
share the work of receiving messages from a topic subscription amongst
multiple consumers. This means that multiple active (not closed)
consumers on the subscription may exist at the same time. A shared
durable subscription is identified by a name specified by the
`durableName` parameter and by the client identifier (which may be
unset, see the `clientId` parameter in link:#aeldy[MQCreateConnection]).

A shared durable subscription and an unshared durable subscription may
not have the same name and client identifier (if set).

There is no restriction on durable subscriptions and shared non-durable
subscriptions having the same name and `clientId` (which may be unset).
Durable subscriptions and shared non-durable subscriptions have separate
name spaces.

A session's consumers are automatically closed when you close the
session or connection to which they belong. To close a consumer without
closing the session or connection to which it belongs, use
link:#aeldr[MQCloseMessageConsumer] function. To delete the durable
subscription, use function
link:#aelgn[MQUnsubscribeDurableMessageConsumer] after all its consumers
are closed.

[[GMCCG456]][[sthref37]]


[[common-errors-16]]
Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_SYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMITE_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONSUMER_NO_DURABLE_NAME
MQ_QUEUE_CONSUMER_CANNOT_BE_DURABLE
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_SHARED_SUBSCRIPTION_NOT_TOPIC
----

[[CIAJABFE]][[GMCCG457]][[mqcreatesharedmessageconsumer]]

MQCreateSharedMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateSharedMessageConsumer` function creates a synchronous
shared non-durable subscription with the specified name (if one does not
already exist) and creates a consumer on that non-durable subscription
for the specified topic destination.

[source,oac_no_warn]
----
MQCreateSharedMessageConsumer
                  (const MQSessionHandle sessionHandle,
                   const MQDestinationHandle destinationHandle,
                   ConstMQString subscriptionName,
                   ConstMQString messageSelector,
                   MQConsumerHandle * consumerHandle);
----

[[GMCCG458]][[sthref38]]


[[return-value-21]]
Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[GMCCG459]][[sthref39]]


[[parameters-24]]
Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is passed back to you by the link:#aeleh[MQCreateSession] function.
  For this (synchronous) consumer, the session must have been created
  with the `MQ_SESSION_SYNC_RECEIVE` receive mode.
`destinationHandle`::
  A handle to the destination on which the consumer receives messages.
  This handle remains valid after the call returns.
`subscriptionName`::
  A `MQString` specifying a name to identify this shared subscription.
  The library makes a copy of the `subscriptionName` string.
`messageSelector`::
  An expression (based on SQL92 conditional syntax) that specifies the
  criteria upon which incoming messages should be selected for this
  consumer. Specify a `NULL` or empty string to indicate that there is
  no message selector for this consumer and that all messages should be
  returned. +
  The library makes a copy of the `messageSelector` string. +
  For more information about SQL, see X/Open CAE Specification Data
  Management: Structured Query Language (SQL), Version 2, ISBN
  1-85912-151-9, March 1966.
`consumerHandle`::
  Output parameter for the handle that references the consumer for the
  specified destination.

You can define parameters to filter messages. The session's receive mode
(sync/async) must be appropriate for the kind of consumer you are
creating (sync/async). To create an asynchronous shared message consumer
for a topic destination, use the
link:#CIACEAJE[MQCreateAsyncSharedMessageConsumer] function.

A non-durable shared subscription is used by a client which needs to be
able to share the work of receiving messages from a topic subscription
amongst multiple consumers. A non-durable shared subscription may
therefore have more than one consumer. Each message from the
subscription will be delivered to only one of the consumers on that
subscription. Such a subscription is not persisted and will be deleted
(together with any undelivered messages associated with it) when there
are no consumers on it.

A session's consumers are automatically closed when you close the
session or connection to which they belong. To close a consumer without
closing the session or connection to which it belongs, use the
link:#aeldr[MQCloseMessageConsumer] function.

[[GMCCG460]][[sthref40]]


[[common-errors-17]]
Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_SYNC_RECEIVE_MODE
MQ_INVALID_MESSAGE_SELECTOR
MQ_DESTINATION_CONSUMER_LIMIT_EXCEEDEED
MQ_TEMPORARY_DESTINATION_NOT_IN_CONNECTION
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_SHARED_SUBSCRIPTION_NOT_TOPIC
----

[[aelei]][[GMCCG00356]][[mqcreatetemporarydestination]]

MQCreateTemporaryDestination
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQCreateTemporaryDestination` function creates a temporary
destination and passes its handle back to you.

[source,oac_no_warn]
----
MQCreateTemporaryDestination(const MQSessionHandle sessionHandle
 MQDestinationType destinationType,
 MQDestinationHandle * destinationHandle);
----

[[gbmde]][[GMCCG00140]][[return-value-22]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcu]][[GMCCG00141]][[parameters-25]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session with which you want to associate this
  destination.
`destinationType`::
  An enum specifying the destination type, either `MQ_QUEUE_DESTINATION`
  or `MQ_TOPIC_DESTINATION`.
`destinationHandle`::
  Output parameter for the handle to the newly created temporary
  destination.

You can use a temporary destination to implement a simple request/reply
mechanism. When you pass the handle of a temporary destination to the
`MQSetMessageReplyTo` function, the consumer of the message can use that
handle as the destination to which it sends a reply.

Temporary destinations are explicitly created by client applications;
they are deleted when the connection is closed. They are maintained (and
named) by the broker only for the duration of the connection for which
they are created. Temporary destinations are system-generated uniquely
for their connection and only their own connection is allowed to create
message consumers for them.

For more information, see "link:../mq-tech-over/client-programming-model.html#GMTOV00056[The Request-Reply Pattern]"
in Open Message Queue Technical Overview and "link:../mq-admin-guide/broker-management.html#GMADG00036[Managing
a Broker] ", "link:../mq-admin-guide/connection-services.html#GMADG00037[Configuring and Managing Connection
Services]" and "link:../mq-admin-guide/administered-objects.html#GMADG00042[Managing Administered Objects]" in Open
Message Queue Administration Guide.

[[gbmdd]][[GMCCG00142]][[common-errors-18]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_INVALID_DESTINATION_TYPE
MQ_SESSION_CLOSED
----

[[aelej]][[GMCCG00357]][[mqcreatetextmessage]]

MQCreateTextMessage
^^^^^^^^^^^^^^^^^^^

The `MQCreatesTextMessage` function creates a text message and passes a
handle to it back to you.

[source,oac_no_warn]
----
MQCreateTextMessage( MQMessageHandle * messageHandle);
----

[[gheto]][[GMCCG00143]][[return-value-23]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gheqf]][[GMCCG00144]][[parameters-26]]

Parameters
++++++++++

`messageHandle`::
  Output parameter for the handle to the new, empty message.

After you obtain the handle to a text message, you can use this handle
to define its content with the
link:#aelfy[MQSetBytesMessageBytes]link:#aelgi[MQSetStringProperty]
function, to set its headers with the link:#aelgf[MQSetMessageHeaders]
function, and to set its properties with the
link:#aelgg[MQSetMessageProperties] function.

[[ghern]][[GMCCG00358]][[mqcreatexasession]]

MQCreateXASession
^^^^^^^^^^^^^^^^^

The `MQCreateXASession` function creates a distributed transaction (XA)
session on an XA connection, defines its behavior, and passes back a
handle to the session.

[source,oac_no_warn]
----
MQCreateXASession(const MQConnectionHandle connectionHandle,
                 MQReceiveMode receiveMode
                 MQMessageListenerBAFunc     beforeMessageListener,
                 MQMessageListenerBAFunc     afterMessageListener,
                 void *                      callbackData,
                 MQSessionHandle * sessionHandle);
----

[[gbmhb]][[GMCCG00145]][[return-value-24]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmha]][[GMCCG00146]][[parameters-27]]

Parameters
++++++++++

`connectionHandle`::
  The handle to the connection to which this session belongs. This
  handle is passed back to you by the link:#gherz[MQGetXAConnection]
  function. You can create multiple sessions on a single connection.
`receiveMode`::
  An enumeration specifying whether this session will do synchronous or
  asynchronous message receives. Specify `MQ_SESSION_SYNC_RECEIVE` or
  `MQ_SESSION_ASYNC_RECEIVE`. +
  If the session is only for producing messages, the `receiveMode` has
  no significance. In that case, specify `MQ_SESSION_SYNC_RECEIVE` to
  optimize the session's resource use.
`beforeMessageListener`::
  A callback function before asynchronous message delivery.
`afterMessageListener`::
  A callback function after asynchronous message delivery.
`callbackData`::
  A data pointer to be passed to the beforeDelivery and afterDelivery
  functions.
`sessionHandle`::
  A handle to this session. You will need to pass this handle to the
  functions you use to manage the session and to create destinations,
  consumers, and producers associated with this session.

If receiveMode is `MQ_SESSION_SYNC_RECEIVE`, pass NULL for
`beforeMessageListener`, `afterMessageListener`, and `callbackData`.

The `MQCreateXASession` function creates a new distributed transaction
(XA) session. The `connectionHandle` must be a XA connection handle.

An XA session is the same as a regular session created by
MQCreateSession (see link:#aeleh[MQCreateSession]) except:

* An XA session is always XA transacted and the distributed transaction
is managed by a X/Open distributed transaction manager.
`MQCommitSession` and `MQRollbackSession` should not be called on a XA
session.
* Sending/receiving messages with an XA session must be done in an XA
transaction.
* If receiveMode is `MQ_SESSION_ASYNC_RECEIVE`, callback functions
`beforeMessageListener` and `afterMessageListener` must be specified.
`beforeMessageListener` will be called by the C-API runtime before it
calls the messageListener callback; `afterMessageListener` will be
called by the C-API runtime after it calls the messageListener callback. +
The `beforeMessageListener` and `afterMessageListener` functions are
provided to the application to associate and disassociate the C-API
runtime calling thread with an XA transaction, to demarcate XA
transactions, and to set appropriate application association context to
the calling thread if the application's distributed transaction
processing environment requires that. +
During normal processing, the C-API runtime:
1.  Calls the `beforeMessageListener` function.
2.  Processes the message, calling the `messageListener` function.
3.  Calls the `afterMessageListener` function. +
However, errors can alter this processing sequence:

** If the `beforeMessageListener` function returns an error (a value
other than `MQ_OK`), the C-API runtime logs a warning message containing
the error code and then stops processing the message. It does not call
`messageListener` or `afterMessageListener`.

** If the attempt to call `messageListener` fails, or if message
acknowledgement fails, the C-API runtime passes the appropriate error
code to `afterMessageListener`.

** If the `messageListener` function returns an error, the C-API runtime
logs a warning containing the error code and then passes the
`MQ_CALLBACK_RUNTIME_ERROR` error to `afterMessageListener`, regardless
of the actual error code returned.

** If the `afterMessageListener` function returns an error, the C-API
runtime logs a warning containing the error code. +
Even if an error occurs, the `callbackData` parameter is passed to the
`beforeMessageListener` and `afterMessageListener` functions unchanged.

[[gheyw]][[GMCCG00147]][[common-errors-19]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_XA_CONNECTION
MQ_INVALID_RECEIVE_MODE
MQ_BROKER_CONNECTION_CLOSED
MQ_COULD_NOT_CREATE_THREAD
----

[[aelek]][[GMCCG00359]][[mqfreeconnection]]

MQFreeConnection
^^^^^^^^^^^^^^^^

The `MQFreeConnection` function deallocates memory assigned to the
specified connection and to all resources associated with that
connection.

[source,oac_no_warn]
----
MQFreeConnection(MQConnectionHandle connectionHandle);
----

[[gbmby]][[GMCCG00148]][[return-value-25]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbt]][[GMCCG00149]][[parameters-28]]

Parameters
++++++++++

`connectionHandle`::
  A handle to the connection you want to free.

You must call this function after you have closed the connection with
the `MQCloseConnection()` function and after all of the application
threads associated with this connection and its dependent sessions,
producers, and consumers have returned.

You must not call this function while an application thread is active in
a library function associated with this connection or one of its
dependent sessions, producers, consumers, and destinations.

Calling this function does not release resources held by a message or a
destination associated with this connection. You must free memory
allocated for a message or a destination by explicitly calling the
`MQFreeMessage` or the `MQFreeDestination` function.

[[gbmbf]][[GMCCG00150]][[common-errors-20]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_STATUS_CONNECTION_NOT_CLOSED
----

[[aelel]][[GMCCG00360]][[mqfreedestination]]

MQFreeDestination
^^^^^^^^^^^^^^^^^

The `MQFreeDestination` function frees memory allocated for the
destination referenced by the specified handle.

[source,oac_no_warn]
----
MQFreeDestination(MQDestinationHandle destinationHandle);
----

[[gbmcb]][[GMCCG00151]][[return-value-26]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcl]][[GMCCG00152]][[parameters-29]]

Parameters
++++++++++

`destinationHandle`::
  A handle to the destination you want to free.

Calling the `MQCloseConnection`, `MQCloseSession` or `MQFreeConnection`
function does not automatically free destinations created for the
connection or for the session.

[[aelem]][[GMCCG00361]][[mqfreemessage]]

MQFreeMessage
^^^^^^^^^^^^^

The `MQFreeMessage` function frees memory allocated for the message
referenced by the specified handle.

[source,oac_no_warn]
----
MQFreeMessage(MQMessageHandle messageHandle);
----

[[gbmbh]][[GMCCG00153]][[return-value-27]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcz]][[GMCCG00154]][[parameters-30]]

Parameters
++++++++++

`messageHandle`::
  A handle to the message you want to free.

Calling the `MQCloseCOnnection`, `MQCloseSession` or `MQFreeConnection`
function does not automatically free messages associated with that
connection or session.

[[aelen]][[GMCCG00362]][[mqfreeproperties]]

MQFreeProperties
^^^^^^^^^^^^^^^^

The `MQFreeProperties` function frees the memory allocated to the
referenced properties object.

[source,oac_no_warn]
----
MQFreeProperties(MQPropertiesHandle propertiesHandle);
----

[[gbmcj]][[GMCCG00155]][[return-value-28]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbk]][[GMCCG00156]][[parameters-31]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object you want to free.

You should not free a properties handle if the properties handle passed
to a function becomes invalid on its return. If you do, you will get an
error.

[[aeleo]][[GMCCG00363]][[mqfreestring]]

MQFreeString
^^^^^^^^^^^^

The `MQFreeString` function frees the memory allocated for the specified
`MQString`.

[source,oac_no_warn]
----
MQFreeString(MQString statusString);
----

[[gbmbz]][[GMCCG00157]][[return-value-29]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcs]][[GMCCG00158]][[parameters-32]]

Parameters
++++++++++

`statusString`::
  An `MQString` returned by the `MQGetStatusString` function or by the
  `MQGetErrorTrace` function.

[[aelep]][[GMCCG00364]][[mqgetacknowledgemode]]

MQGetAcknowledgeMode
^^^^^^^^^^^^^^^^^^^^

The `MQGetAcknowledgeMode` function passes back the acknowledgement mode
of the specified session.

[source,oac_no_warn]
----
MQGetAcknowledgemode(const MQSessionHandle sessionHandle
                           MQAckMode * ackMode);
----

[[gbmco]][[GMCCG00159]][[return-value-30]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcv]][[GMCCG00160]][[parameters-33]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session whose acknowledgement mode you want to
  determine.
`ackMode`::
  Output parameter for the `ackMode`. The `ackMode` returned can be one
  of four enumeration values. See link:#aeldl[Acknowledge Modes] for
  information about these values.

If you want to change the acknowledge mode, you need to create another
session with the desired mode.

[[aeleq]][[GMCCG00365]][[mqgetboolproperty]]

MQGetBoolProperty
^^^^^^^^^^^^^^^^^

The `MQGetBoolProperty` function passes back the value of the `MQBool`
property for the specified key.

[source,oac_no_warn]
----
MQGetBoolProperty(const MQPropertiesHandle propertiesHandle,
                        ConstMQString key,
                        MQBool * value);
----

[[gbmbr]][[GMCCG00161]][[return-value-31]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmci]][[GMCCG00162]][[parameters-34]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the specified key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter for the property value.

[[gbmbs]][[GMCCG00163]][[common-errors-21]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_FOUND
MQ_INVALID_TYPE_CONVERSION
----

[[aeler]][[GMCCG00366]][[mqgetbytesmessagebytes]]

MQGetBytesMessageBytes
^^^^^^^^^^^^^^^^^^^^^^

The `MQGetBytesMessageBytes` function passes back the address and size
of a bytes message body.

[source,oac_no_warn]
----
MQGetBytesMessageBytes(const MQMessageHandle messageHandle,
 const MQInt8 * messageBytes
 MQInt32 * messageBytesSize);
----

[[gbmbm]][[GMCCG00164]][[return-value-32]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbv]][[GMCCG00165]][[parameters-35]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message that is passed to you when you receive a
  message.
`messageBytes`::
  Output parameter that contains the start address of the bytes that
  constitute the body of this bytes message.
`messageBytesSize`::
  Output parameter that contains the size of the message body in bytes.

After you obtain the handle to a message, you can use the
link:#aelfd[MQGetMessageType] function to determine its type and, if the
type is `MQ_BYTES_MESSAGE`, you can use the `MQGetBytesMessageBytes`
function to retrieve the message bytes (message body).

The bytes message passed to you by this function is not a copy. You
should not modify the bytes or attempt to free it.

[[ghevs]][[GMCCG00367]][[mqgetconnectionproperties]]

MQGetConnectionProperties
^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQGetConnectionProperties` function gets the connection properties
used to create the connection specified by s `connectionHandle`.

[source,oac_no_warn]
----
MQGetConnectionProperties (const MQConnectionHandle connectionHandle,
MQPropertiesHandle * propertiesHandle);
----

[[ghezj]][[GMCCG00166]][[return-value-33]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[ghezk]][[GMCCG00167]][[parameters-36]]

Parameters
++++++++++

`connectionHandle`::
  A handle to a connection.
`propertiesHandle`::
  A handle to the properties of the connection.

The caller is responsible to free the returned connection properties by
calling `MQFreeProperties`.

[[CIAFJBHF]][[GMCCG461]][[mqgetdeliverydelay]]

MQGetDeliveryDelay
^^^^^^^^^^^^^^^^^^

The `MQGetDeliveryDelay` function gets the `deliveryDelay` for messages
specified by `producerHandle`.

[source,oac_no_warn]
----
MQGetDeliveryDelay 
                  (const MQProducer producerHandle,
                   MQInt64 deliveryDelay);
----

[[GMCCG462]][[sthref41]]


[[return-value-34]]
Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[GMCCG463]][[sthref42]]


[[parameters-37]]
Parameters
++++++++++

`producerHandle`::
  The handle to the producer sending this message. This handle is passed
  back to you by the link:#aelef[MQCreateMessageProducerForDestination]
  function.
`deliveryDelay`::
  The amount of time, in milliseconds, used to delay a message's
  delivery time. +
  This value is added to the time the message was sent to calculate the
  delivery time, which is the earliest time that a JMS provider may
  deliver a message to a consumer. A JMS provider must not delivery
  messages before the delivery time has been reached. When specified,
  the `MQ_DELIVERY_TIME_HEADER_PROPERTY` is ignored.

[[gbjog]][[GMCCG00368]][[mqgetdestinationname]]

MQGetDestinationName
^^^^^^^^^^^^^^^^^^^^

The `MQGetDestinatioName` function passes back the name of the specified
destination.

[source,oac_no_warn]
----
MQGetDestinationName (const MQDestinationHandle destinationHandle,
                             MQString * destinationName);
----

[[gbmcn]][[GMCCG00168]][[return-value-35]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcc]][[GMCCG00169]][[parameters-38]]

Parameters
++++++++++

`destinationHandle`::
  A handle to the destination whose name you want to know.
`destinationName`::
  Output parameter for the destination name. The returned
  `destinationName` is a copy which the caller is responsible for
  freeing by calling the `MQFreeString()` function

Use the `MQGetDestinationName` function to get the name of a
destination. This might be useful for applications that want to do some
message processing based on the destination name.

This function is useful when using the Reply-To pattern. You can use the
`MQGetMessageReplyTo` function to obtain a handle to the destination
where the message should be sent. You can then use the
`MQGetDestinationName` to get the name of that destination.

[[aeles]][[GMCCG00369]][[mqgetdestinationtype]]

MQGetDestinationType
^^^^^^^^^^^^^^^^^^^^

The `MQGetDestinationType` passes back the type of the specified
destination.

[source,oac_no_warn]
----
MQGetDestinationType (const MQDestinationHandle destinationHandle,
 MQDestinationType * destinationType);
----

[[gbmbw]][[GMCCG00170]][[return-value-36]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbp]][[GMCCG00171]][[parameters-39]]

Parameters
++++++++++

`destinationHandle`::
  A handle to the destination whose type you want to know.
`destinationType`::
  Output parameter for the destination type; either
  `MQ_QUEUE_DESTINATION` or `MQ_TOPIC_DESTINATION`.

Use the `MQGetDestinationType` function to determine the type of a
destination: queue or topic. There may be times when you do not know the
type of the destination to which you are replying: for example, when you
get a handle from the `MQGetMessageReplyTo` function. Because the
semantics of queue and topic destinations differ, you need to determine
the type of a destination in order to reply appropriately.

Once you have created a destination with a specified type, you cannot
change the type dynamically. If you want to change the type of a
destination, you need to free the destination using the
link:#aelel[MQFreeDestination] function and then to create a new
destination, with the desired type, using the
link:#aeleb[MQCreateDestination] or the
link:#aelei[MQCreateTemporaryDestination] function.

[[aelet]][[GMCCG00370]][[mqgeterrortrace]]

MQGetErrorTrace
^^^^^^^^^^^^^^^

The `MQGetErrorTrace` function returns an `MQString` describing the
error trace at the time when a function call failed for the calling
thread.

[source,oac_no_warn]
----
MQString MQGetErrorTrace ()
----

Having found that a Message Queue function has not returned
successfully, you can get an error trace when the error occurred by
calling the `MQGetErrorTrace` function in the same thread that called
the unsuccessful Message Queue function.

The `MQGetErrorTrace` function returns an `MQString` describing the
error trace if it can determine this information. The function will
return a `NULL` string if there is no error trace available.

The following is an example of an error trace output.

[source,oac_no_warn]
----
connect:../../../../src/share/cclient/io/TCPSocket.cpp:195:mq:-5981
readBrokerPorts:../../../../src/share/cclient/client/PortMapper
                                                Client.cpp:48:mq:-5981
connect:../../../../../src/share/cclient/client/protocol/
                                    TCPProtocolHandler.cpp:111:mq:-5981
connectToBroker:../../../../src/share/cclient/client/Connection.
                                                     cpp:412:mq:-5981
openConnection:../../../../src/share/cclient/client/Connection.
                                                     cpp:227:mq:1900
MQCreateConnectionExt:../../../../src/share/cclient/cshim/
                                        iMQConnectionShim.cpp:102:mq:1900
----

You must call the link:#aeleo[MQFreeString] function to free the
`MQString` returned by the `MQGetErrorTrace` function when you are done.

[[aeleu]][[GMCCG00172]][[mqgetfloat32property]]

MQGetFloat32Property
++++++++++++++++++++

The `MQGetFloat32Property` function passes back the value of the
`MQFloat32` property for the specified key.

[source,oac_no_warn]
----
MQGetFloat32Property(const MQPropertiesHandle propertiesHandle,
                           ConstMQString key,
                           MQFloat32 * value);
----

[[gbmcx]][[GMCCG00173]][[return-value-37]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbe]][[GMCCG00174]][[parameters-40]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter for the property value.

[[gbmdb]][[GMCCG00175]][[common-errors-22]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_FOUND
MQ_INVALID_TYPE_CONVERSION
----

[[aelev]][[GMCCG00371]][[mqgetfloat64property]]

MQGetFloat64Property
^^^^^^^^^^^^^^^^^^^^

The `MQGetFloat64Property` function passes back the value of the
`MQFloat64` property for the specified key.

[source,oac_no_warn]
----
MQGetFloat64Property(const MQPropertiesHandle propertiesHandle,
 ConstMQString key,
 MQFloat64 * value);
----

[[gbmct]][[GMCCG00176]][[return-value-38]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmce]][[GMCCG00177]][[parameters-41]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter for the property value.

[[gbmbq]][[GMCCG00178]][[common-errors-23]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_FOUND
MQ_INVALID_TYPE_CONVERSION
----

[[aelew]][[GMCCG00372]][[mqgetint16property]]

MQGetInt16Property
^^^^^^^^^^^^^^^^^^

The `MQGetInt16Property` function passes back the value of the `MQInt16`
property for the specified key.

[source,oac_no_warn]
----
MQGetInt16Property(const MQPropertiesHandle propertiesHandle,
                         ConstMQString key,
                         MQInt16 * value);
----

[[gbmcg]][[GMCCG00179]][[return-value-39]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbx]][[GMCCG00180]][[parameters-42]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the specified key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter for the property value.

[[gbmbn]][[GMCCG00181]][[common-errors-24]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_FOUND
MQ_INVALID_TYPE_CONVERSION
----

[[aelex]][[GMCCG00373]][[mqgetint32property]]

MQGetInt32Property
^^^^^^^^^^^^^^^^^^

The `MQGetInt32Property` function passes back the value of the `MQInt32`
property for the specified key.

[source,oac_no_warn]
----
MQGetInt32Property(const MQPropertiesHandle propertiesHandle,
                         ConstMQString key,
                         MQInt32 * value);
----

[[gbmcw]][[GMCCG00182]][[return-value-40]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbo]][[GMCCG00183]][[parameters-43]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter for the property value.

[[gbmca]][[GMCCG00184]][[common-errors-25]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_FOUND
MQ_INVALID_TYPE_CONVERSION
----

[[aeley]][[GMCCG00374]][[mqgetint64property]]

MQGetInt64Property
^^^^^^^^^^^^^^^^^^

The `MQGetInt64Property` function passes back the value of the MQInt64
property for the specified key.

[source,oac_no_warn]
----
MQGetint64Property (const MQPropertiesHandle propertiesHandle,
                          ConstMQString key,
                          MQInt64 * value);
----

[[gbmbu]][[GMCCG00185]][[return-value-41]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmbl]][[GMCCG00186]][[parameters-44]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter for the property value.

[[gbmcd]][[GMCCG00187]][[common-errors-26]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_FOUND
MQ_INVALID_TYPE_CONVERSION
----

[[aelez]][[GMCCG00375]][[mqgetint8property]]

MQGetInt8Property
^^^^^^^^^^^^^^^^^

The `MQGetInt8Property` function passes back the value of the `MQInt8`
property for the specified key.

[source,oac_no_warn]
----
MQGetInt8Property (const MQPropertiesHandle propertiesHandle,
                         ConstMQString key,
                         MQInt8 * value);
----

[[gbmbi]][[GMCCG00188]][[return-value-42]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcm]][[GMCCG00189]][[parameters-45]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter for the property value.

[[gbmcp]][[GMCCG00190]][[common-errors-27]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_FOUND
MQ_INVALID_TYPE_CONVERSION
----

[[aelfa]][[GMCCG00376]][[mqgetmessageheaders]]

MQGetMessageHeaders
^^^^^^^^^^^^^^^^^^^

The `MQGetMessageHeaders` function passes back a handle to the message
headers.

`MQGetMessageHeaders`::
[source,oac_no_warn]
----
(const MQMessageHandle messageHandle
 MQPropertiesHandle * headersHandle) ;
----

[[gbmcf]][[GMCCG00191]][[return-value-43]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmcr]][[GMCCG00192]][[parameters-46]]

Parameters
++++++++++

`messageHandle`::
  The message handle.
`headersHandle`::
  Output parameter for the handle to the message header properties.

The `MQGetMessageHeaders` function passes back a handle to the message
headers. The message header includes the fields described in
link:#gbmck[Table 4-5]. Note that most of the fields are set by the send
function; the client can optionally set only two of these fields for
sending messages.

[[GMCCG464]][[sthref43]][[gbmck]]


Table 4-5 Message Header Properties

[width="100%",cols="56%,20%,24%",options="header",]
|======================================
|Key |Type |Set By
|`MQ_CORRELATION_ID_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQString
----

 |Client (optional)
|`MQ_DELIVERY_TIME_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQInt64 (Readonly)
----

 |Send function
|`MQ_MESSAGE_TYPE_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQString
----

 |Client (optional)
|`MQ_PERSISTENT_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQBool
----

 |Send function
|`MQ_EXPIRATION_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQInt64
----

 |Send function
|`MQ_PRIORITY_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQInt8
----

 |Send function
|`MQ_TIMESTAMP_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQInt64
----

 |Send function
|`MQ_MESSAGE_ID_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQString
----

 |Send function
|`MQ_REDELIVERED_HEADER_PROPERTY` a|
[source,oac_no_warn]
----
MQBool
----

 |Message Broker
|======================================


You are responsible for freeing the `headersHandle` after you are done
with it. Use the link:#aelen[MQFreeProperties] function to free the
handle.

Use the link:#aelfy[MQSetBytesMessageBytes]
link:#aelfb[MQGetMessageProperties] function to determine whether any
application-defined properties were set for this message and to find out
their value.

[[aelfb]][[GMCCG00377]][[mqgetmessageproperties]]

MQGetMessageProperties
^^^^^^^^^^^^^^^^^^^^^^

The `MQGetMessageProperties` function passes back the user-defined
properties for a message.

[source,oac_no_warn]
----
MQGetMessageProperties (const MQMessageHandle messageHandle,
                              MQPropertiesHandle * propsHandle);
----

[[gbmcy]][[GMCCG00193]][[return-value-44]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmch]][[GMCCG00194]][[parameters-47]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message whose properties you want to get.
`propertiesHandle`::
  Output parameter for the handle to the message properties.

The `MQGetMessageProperties` function allows you to get
application-defined properties for a message. Properties allow an
application, via message selectors, to select or filter messages on its
behalf using application-specific criteria. Having obtained the handle,
you can either use one of the `MQGet...Property` functions to get a
value (if you know the key name) or you can iterate through the
properties using the link:#aelfn[MQPropertiesKeyIterationStart]
function.

You will need to call the function `MQFreeProperties()` to free the
resources associated with this handle after you are done using it.

[[gbmcq]][[GMCCG00195]][[common-errors-28]]

Common Errors
+++++++++++++

`MQ_NO_MESSAGE_PROPERTIES`

[[aelfc]][[GMCCG00378]][[mqgetmessagereplyto]]

MQGetMessageReplyTo
^^^^^^^^^^^^^^^^^^^

The `MQGetMessageReplyTo` function passes back the destination where
replies to this message should be sent.

[source,oac_no_warn]
----
MQGetMessageReplyTo (const MQMessageHandle messageHandle,
                           MQDestinationHandle * destinationHandle);
----

[[gbmdc]][[GMCCG00196]][[return-value-45]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmdv]][[GMCCG00197]][[parameters-48]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message expecting a reply. This is the handle that is
  passed back to you when you receive the message.
`destinationHandle`::
  Output parameter for the handle to the reply destination.

The sender uses the link:#aelgh[MQSetMessageReplyTo] function to specify
a destination where replies to the message can be sent. This can be a
normal destination or a temporary destination. The receiving client can
pass the message handle to the link:#aelfc[MQGetMessageReplyTo] function
and determine whether a destination for replies has been set up for the
message by the sender and what that destination is. The consumer of the
message can then use that handle as the destination to which it sends a
reply.

You might need to call the `MQGetDestinationType` function to determine
the type of the destination whose handle is returned to you: queue or
topic so that you can set up your reply appropriately.

The advantage of setting up a temporary destination for replies is that
Message Queue automatically creates a physical destination for you,
rather than your having to have the administrator create one, when the
broker's `auto.create.destination` property is turned off.

You are responsible for freeing the destination handle by calling the
function `MQFreeDestination.()`

[[gbmeu]][[GMCCG00198]][[common-errors-29]]

Common Errors
+++++++++++++

`MQ_NO_REPLY_TO_DESTINATION`

[[aelfd]][[GMCCG00379]][[mqgetmessagetype]]

MQGetMessageType
^^^^^^^^^^^^^^^^

The `MQGetMessageType` function passes back information about the type
of a message: `MQ_TEXT_MESSAGE`, `MQ_BYTES_MESSAGE` , or `MQ_MESSAGE`.

[source,oac_no_warn]
----
MQGetMessageType(const MQMessageHandle messageHandle,
                       MQMessageType * messageType);
----

[[gbmey]][[GMCCG00199]][[return-value-46]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmdt]][[GMCCG00200]][[parameters-49]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message whose type you want to determine.
`messageType`::
  Output parameter that contains the message type: `MQ_TEXT_MESSAGE` or
  `MQ_BYTES_MESSAGE`.

After you obtain the handle to a message, you can determine the type of
the message using the `MQGetMessageType` function. Having determined its
type, you can use the link:#aelfj[MQGetTextMessageText] function or the
link:#aeler[MQGetBytesMessageBytes] function to obtain the message
content.

Note that other message types might be added in the future. You should
not design your code so that it only expects two possible message types.

[[aelfe]][[GMCCG00380]][[mqgetmetadata]]

MQGetMetaData
^^^^^^^^^^^^^

The `MQGetMetaData` function returns name and version information for
the current Message Queue service to which a client is connected.

[source,oac_no_warn]
----
MQGetMetaData (const MQConnectionHandle connectionHandle,
                     MQPropertiesHandle * propertiesHandle)
----

[[gbmdp]][[GMCCG00201]][[return-value-47]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmes]][[GMCCG00202]][[parameters-50]]

Parameters
++++++++++

`connectionHandle`::
  The handle to the connection that you want the information about.
`propertiesHandle`::
  Output parameter that contains the properties handle.

The Message Queue product you are using is identified by a name and a
version number. For example: "Sun Java(tm) System Message Queue 3.5.1."
The version number consists of a major, minor, micro, and update release
component. For example, the major part of version 3.5.1. is 3; the minor
is 5; and the micro is 1. For release 3.7 UR1, the major part is 3; the
minor is 7; and the update release is 1.

The name and version information of the Message Queue product are set by
the library when you call the link:#aeldy[MQCreateConnection] function
to create the connection. You can retrieve this information by calling
the `MQGetMetaData` function and passing a properties handle. Once the
function returns and passes the handle back, you can use one of the
`MQGet...Properties` functions to determine the value of a property
(key). These properties are described in link:#gcsrb[Table 4-2].

[[aelff]][[GMCCG00381]][[mqgetpropertytype]]

MQGetPropertyType
^^^^^^^^^^^^^^^^^

The `MQGetPropertyType` function returns the type of the property value
for a property key in the specified properties handle.

[source,oac_no_warn]
----
MQGetPropertyType (const MQPropertiesHandle  propertiesHandle,
                         ConstMQString key,
                         MQType * propertyType);
----

[[gbmdy]][[GMCCG00203]][[return-value-48]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmeq]][[GMCCG00204]][[parameters-51]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle that you want to access.
`key`::
  The property key for which you want to get the type of the property
  value.
`propertyType`::
  Output parameter for the type of the property value.

Use the appropriate `MQGet...Property` function to find the value of the
specified property key.

[[gbmet]][[GMCCG00205]][[common-errors-30]]

Common Errors
+++++++++++++

`MQ_NOT_FOUND`

[[aelfg]][[GMCCG00382]][[mqgetstatuscode]]

MQGetStatusCode
^^^^^^^^^^^^^^^

The `MQGetStatusCode` function returns the error code associated with
specified status.

[source,oac_no_warn]
----
MQError MQGetStatusCode(const MQStatus status);
----

[[gbmew]][[GMCCG00206]][[parameters-52]]

Parameters
++++++++++

`status`::
  The status returned by any Message Queue function that returns an
  `MQStatus`.

Having found that a Message Queue function has not returned
successfully, you can determine the reason by passing the return status.
This function will return the error code associated with the specified
status. These codes are listed and described in
link:capi-error-codes.html#aelgp[Message Queue C API Error Codes].

Some functions might return an `MQStatus` that contains an NSPR or NSS
library error code instead of a Message Queue error code when they fail.
For NSPR and NSS library error codes, the `MQGetStatusString` function
will return the symbolic name of the NSPR or NSS library error code. See
NSPR and NSS public documentation for NSPR and NSS error code symbols
and their interpretation at the following locations:

* For NSPR error codes, see the "NSPR Error Handling" chapter at the
following location:
`http://www.mozilla.org/projects/nspr/reference/html/index.html`.
* For SSL and SEC error codes, see the "NSS and SSL Error Codes" chapter
at the following location:
`http://www.mozilla.org/projects/security/pki/nss/ref/ssl/`.

To obtain an `MQString` that describes the error, use the
link:#aelfh[MQGetStatusString] function. To get an error trace
associated with the error, use the link:#aelet[MQGetErrorTrace]
function.

[[aelfh]][[GMCCG00383]][[mqgetstatusstring]]

MQGetStatusString
^^^^^^^^^^^^^^^^^

The `MQGetStatusString` function returns an `MQString` describing the
specified status.

[source,oac_no_warn]
----
MQString MQGetStatusString(const MQStatus status);
----

[[gbmeh]][[GMCCG00207]][[parameters-53]]

Parameters
++++++++++

`status`::
  The status returned by any Message Queue function that returns an
  `MQStatus`.

Having found that a Message Queue function has not returned
successfully, you can determine the reason why by passing the return
status. This function will return an `MQString` describing the error
associated with the specified status.

To obtain the error code for the specified `status`, use the
link:#aelfg[MQGetStatusCode] function. To get an error trace associated
with the error, use the link:#aelet[MQGetErrorTrace] function.

You must call the `MQFreeString` function to free the `MQString`
returned by the `MQGetStatusString` function when you are done.

[[aelfi]][[GMCCG00384]][[mqgetstringproperty]]

MQGetStringProperty
^^^^^^^^^^^^^^^^^^^

The `MQGetStringProperty` function passes back the value of the
specified key for the specified `MQString` property.

[source,oac_no_warn]
----
MQGetStringProperty(const MQPropertiesHandle propertiesHandle,
                          ConstMQString key,
                          ConstMQString * value);
----

[[gbmdf]][[GMCCG00208]][[return-value-49]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmea]][[GMCCG00209]][[parameters-54]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle for the key you want to get.
`key`::
  The name of a property key.
`value`::
  Output parameter that points to the value of the specified key

You should not modify or attempt to free the value returned.

[[aelfj]][[GMCCG00385]][[mqgettextmessagetext]]

MQGetTextMessageText
^^^^^^^^^^^^^^^^^^^^

The `MQGetTextMessageText` function passes back the contents of a text
message.

[source,oac_no_warn]
----
MQGetTextMessageText(const MQMessageHandle messageHandle,
                           ConstMQString * messageText);
----

[[ghepf]][[GMCCG00210]][[return-value-50]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[ghesc]][[GMCCG00211]][[parameters-55]]

Parameters
++++++++++

`messageHandle`::
  A handle to an `MQ_TEXT_MESSAGE` message that is passed to you when
  you receive a message.
`messageText`::
  The output parameter that points to the message text.

After you obtain the handle to a message, you can use the
`MQGetMessageType ()` function to determine its type and, if the type is
text, you can use the `MQGetTextMessageText()` function to retrieve the
message text.

The `MQString` passed to you by this function is not a copy. You should
not modify the bytes or attempt to free it.

[[gherz]][[GMCCG00386]][[mqgetxaconnection]]

MQGetXAConnection
^^^^^^^^^^^^^^^^^

The `MQGetXAConnection` function passes back a handle to an XA
connection. This should only be called when the Message Queue C-API is
used in a X/Open distributed transaction processing environment with
Message Queue as an XA-compliant resource manager.

[source,oac_no_warn]
----
MQGetXAConnection(MQConnectionHandle * connectionHandle);
----

[[gbmds]][[GMCCG00212]][[return-value-51]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmdu]][[GMCCG00213]][[parameters-56]]

Parameters
++++++++++

`connectionHandle`::
  A handle to an XA connection.

`MQCloseConnection` should not be called on an XA connection handle.

[[ghewd]][[GMCCG00214]][[common-errors-31]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_STATUS_INVALID_HANDLE
----

[[aelfk]][[GMCCG00387]][[mqinitializessl]]

MQInitializeSSL
^^^^^^^^^^^^^^^

The `MQInitializeSSL` function initializes the SSL library.

[source,oac_no_warn]
----
MQInitializeSSL (ConstMQString certificateDatabasePath);
----

[[gbmdj]][[GMCCG00215]][[return-value-52]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmem]][[GMCCG00216]][[parameters-57]]

Parameters
++++++++++

`certificateDatabasePath`::
  An `MQString` specifying the path to the directory that contains the
  certificate data base files.

The Message Queue C-API library uses NSS to support the SSL transport
protocol between the Message Queue C client and the Message Queue
broker.

Before you connect to a broker over SSL, you must initialize the SSL
library by calling the `MQInitializeSSL` function. If your client uses
secure connections, you must call this function once and only once
before you create any connection, even if that connection is not an SSL
connection.

The `certificateDatabasePath` parameter specifies the path to the NSS
certificate database where `cert7.db` or `cert8.db` , `key3.db`, and
`secmod.db` files are located.

The work required to configure secure communication includes
initializing the SSL library using the `MQInitializeSSL` function. There
may be additional work, depending on whether the broker is trusted (the
default setting) and on whether you want to provide an additional means
of verification if the broker is not trusted and the initial attempt to
create a secure connection fails. For complete information see
link:using-the-c-api.html#aelbl[Working With Secure Connections].

You must take care if the client application using secure Message Queue
connections uses NSS (for other purposes) directly as well and does NSS
initialization. For additional information, see
link:using-the-c-api.html#aelbo[Coordinating NSS Initialization].

[[gbmdl]][[GMCCG00217]][[common-errors-32]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_INCOMPATIBLE_LIBRARY
MQ_SSL_ALREADY_INITIALIZED
MQ_SSL_INIT_ERROR
----

[[aelfl]][[GMCCG00388]][[mqpropertieskeyiterationgetnext]]

MQPropertiesKeyIterationGetNext
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQPropertiesKeyIterationGetNext` function passes back the address
of the next property key in the referenced properties handle.

[source,oac_no_warn]
----
MQPropertiesKeyIterationGetNext
                                            (const MQPropertiesHandle propertiesHandle,
                        ConstMQString * key);
----

[[gbmeb]][[GMCCG00218]][[return-value-53]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmex]][[GMCCG00219]][[parameters-58]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle whose contents you want to access.
`key`::
  The output parameter for the next properties key in the iteration. You
  should not attempt to modify or free it.

[[gbmeg]][[GMCCG00026]][[to-get-message-properties]]

To Get Message Properties

Follow this procedure:

1.  Start the process by calling the `MQPropertiesKeyIterationStart ()`
function.
2.  Loop using the `MQPropertiesKeyIterationHasNext()` function.
3.  Extract the name of each property key by calling the
`MQPropertiesKeyIterationGetNext ()` function.
4.  Determine the type of the property value for a given key by calling
the `MQGetPropertyType()` function.
5.  Use the appropriate `MQGet...Property` function to find the property
value for the specified property key. +
If you know the property key, you can just use the appropriate
`MQGet...Property` function to access its value. +
You should not modify or free the property key that is passed back to
you by this function. Note that this function is not multi-thread-safe.

[[aelfm]][[GMCCG00389]][[mqpropertieskeyiterationhasnext]]

MQPropertiesKeyIterationHasNext
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQPropertiesKeyIterationHasNext` function returns `MQ_TRUE` if
there are additional property keys left in the iteration.

[source,oac_no_warn]
----
MQPropertiesKeyIterationHasNext
              (const MQPropertiesHandle  propertiesHandle);
----

[[gbmdx]][[GMCCG00220]][[return-value-54]]

Return Value
++++++++++++

MQBool

[[gbmep]][[GMCCG00221]][[parameters-59]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle that you want to access.

[[gbmel]][[GMCCG00027]][[to-get-message-properties-1]]

To Get Message Properties

Follow this procedure:

1.  Start the process by calling the `MQPropertiesKeyIterationStart ()`
function.
2.  Loop using the `MQPropertiesKeyIterationHasNext()` function.
3.  Extract the name of each property key by calling the
`MQPropertiesKeyIterationGetNext ()` function.
4.  Determine the type of the property value for a given key by calling
the `MQGetPropertyType()` function.
5.  Use the appropriate `MQGet...Property` function to find the value
for the specified property key. +
If you know the property key, you can just use the appropriate
`MQGet...Property` function to get its value. Note that this function is
not multi-thread-safe.

[[aelfn]][[GMCCG00390]][[mqpropertieskeyiterationstart]]

MQPropertiesKeyIterationStart
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQPropertiesKeyIterationStart` function starts or resets the
iteration process or the specified properties handle.

[source,oac_no_warn]
----
MQPropertiesKeyIterationStart
              (const PropertiesHandle propertiesHandle);
----

[[gbmek]][[GMCCG00222]][[return-value-55]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmdo]][[GMCCG00223]][[parameters-60]]

Parameters
++++++++++

`propertiesHandle`::
  A properties handle that you want to access.

[[gbmdr]][[GMCCG00028]][[to-get-message-properties-2]]

To Get Message Properties

Follow this procedure:

1.  Start the process by calling the `MQPropertiesKeyIterationStart ()`
function.
2.  Loop using the `MQPropertiesKeyIterationHasNext()` function.
3.  Extract the name of each property key by calling the
`MQPropertiesKeyIterationGetNext ()` function.
4.  Determine the type of the property value for a given key by calling
the `MQGetPropertyType()` function.
5.  Use the appropriate `MQGet...Property` function to find the property
value for the specified property key. +
If you know the property key, you can just use the appropriate
`MQGet...Property` function to get its value. Note that this function is
not multi-thread-safe.

[[aelfo]][[GMCCG00391]][[mqreceivemessagenowait]]

MQReceiveMessageNoWait
^^^^^^^^^^^^^^^^^^^^^^

The `MQReceiveMessageNoWait` function passes a handle back to a message
delivered to the specified consumer if a message is available.

[source,oac_no_warn]
----
MQReceiveMessageNoWait(const MQConsumerHandle consumerHandle,
                                                      MQMessageHandle * messageHandle);
----

[[gbmfb]][[GMCCG00224]][[return-value-56]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmdg]][[GMCCG00225]][[parameters-61]]

Parameters
++++++++++

`consumerHandle`::
  The handle to the message consumer. This handle is passed back to you
  when you create a synchronous message consumer.
`messageHandle`::
  Output parameter for the handle to the message to be received. You are
  responsible for freeing the message handle when you are done by
  calling the `MQFreeMessage()` function.

This function can only be called if the session is created with receive
mode `MQ_SESSION_SYNC_RECEIVE`. The `MQReceiveMessageNoWait` function
passes a handle back to you in the `messageHandle` parameter if there is
a message arrived for the consumer specified by the `consumerHandle`
parameter. If there is no message for the consumer, the function returns
immediately with an error.

When you create a session, you specify one of several acknowledge modes
for that session; these are described in link:#aeldl[Acknowledge Modes].
If you specify `MQ_CLIENT_ACKNOWLEDGE` as the acknowledge mode for the
session, you must explicitly call the `MQAcknowledgeMessages` function
to acknowledge messages that you have received. For more information,
see the description of the function link:#aeldp[MQAcknowledgeMessages].

Because distributed applications involve greater processing time, such
an application might not behave as expected if it were run locally. For
example, calling the `MQReceiveMessageNoWait` function might return
`MQ_NO_MESSAGE` even when there is a message available to be retrieved.

If a client connects to the broker and immediately calls the
`MQReceiveMessageNoWait` , it is possible that the message queued for
the consuming client is in the process of being transmitted from the
broker to the client. The client runtime has no knowledge of what is on
the broker, so when it sees that there is no message available on the
client's internal queue, it returns with `MQ_NO_MESSAGE` .

You can avoid this problem by having your client use one of the
synchronous receive methods that specifies a timeout interval.

You can use the link:#aelfp[MQReceiveMessageWait] function if you want
the receive function to block while waiting for a message to arrive. You
can use the link:#aelfq[MQReceiveMessageWithTimeout] function to wait
for a specified time for a message to arrive.

[[gbmdi]][[GMCCG00226]][[common-errors-33]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_SYNC_RECEIVE_MODE
MQ_CONCURRENT_ACCESS
MQ_NO_MESSAGE
MQ_CONSUMER_CLOSED
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_THREAD_OUTSIDE_XA_TRANSACTION
MQ_XA_SESSION_NO_TRANSATION
----

[[aelfp]][[GMCCG00392]][[mqreceivemessagewait]]

MQReceiveMessageWait
^^^^^^^^^^^^^^^^^^^^

The `MQReceiveMessageWait` function passes a handle back to a message
delivered to the specified consumer when the message becomes available.

[source,oac_no_warn]
----
MQReceiveMessageWait (const MQConsumerHandle consumerHandle,
                                MQMessageHandle * messageHandle);
----

[[gbmef]][[GMCCG00227]][[return-value-57]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmec]][[GMCCG00228]][[parameters-62]]

Parameters
++++++++++

`consumerHandle`::
  The handle to the message consumer. This handle is passed back to you
  when you create a synchronous message consumer.
`messageHandle`::
  Output parameter for the handle to the message to be received. You are
  responsible for freeing the message handle when you are done by
  calling the `MQFreeMessage()` function.

This function can only be called if the session is created with receive
mode `MQ_SESSION_SYNC_RECEIVE`. The `MQReceiveMessageWait` function
passes a handle back to you in the `messageHandle` parameter if there is
a message arrived for the consumer specified by the `consumerHandle`
parameter. If there is no message for the consumer, the function blocks
until a message is delivered.

When you create a session, you specify one of several acknowledge modes
for that session; these are described in link:#aeldl[Acknowledge Modes].
If you specify `MQ_CLIENT_ACKNOWLEDGE` as the acknowledge mode for the
session, you must explicitly call the `MQAcknowledgeMessages` function
to acknowledge messages that you have received. For more information,
see the description of the function link:#aeldp[MQAcknowledgeMessages].

You can use the link:#aelfo[MQReceiveMessageNoWait] function instead if
you do not want to block while waiting for a message to arrive. You can
use the function link:#aelfq[MQReceiveMessageWithTimeout] to wait for a
specified time for a message to arrive.

[[gbmeo]][[GMCCG00229]][[common-errors-34]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_SYNC_RECEIVE_MODE
MQ_CONCURRENT_ACCESS
MQ_CONSUMER_CLOSED
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_THREAD_OUTSIDE_XA_TRANSACTION
MQ_XA_SESSION_NO_TRANSATION
----

[[aelfq]][[GMCCG00393]][[mqreceivemessagewithtimeout]]

MQReceiveMessageWithTimeout
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQReceiveMessageWithTimeout` function passes a handle back to a
message delivered to the specified consumer if a message is available
within the specified amount of time.

[source,oac_no_warn]
----
MQReceiveMessageWithTimeout
                                            (const MQConsumerHandle consumerHandle,
                                             MQInt32 timeoutMilliseconds,
                                             MQMessageHandle * messageHandle);
----

[[gbmdz]][[GMCCG00230]][[return-value-58]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbrdm]][[GMCCG00231]][[parameters-63]]

Parameters
++++++++++

`consumerHandle`::
  The handle to the message consumer. This handle is passed back to you
  when you create a synchronous message consumer.
`timeoutMilliseconds`::
  The number of milliseconds to wait for a message to arrive.
`messageHandle`::
  Output parameter for the handle to the message to be received. You are
  responsible for freeing the message handle when you are done by
  calling the `MQFreeMessage()` function.

This function can only be called if the session is created with receive
mode `MQ_SESSION_SYNC_RECEIVE`. The
link:#aelfq[MQReceiveMessageWithTimeout] function passes a handle back
to you in the `messageHandle` parameter if a message arrives for the
consumer specified by the `consumerHandle` parameter in the amount of
time specified by the `timoutMilliseconds` parameter. If no message
arrives within the specified amount of time, the function returns an
error.

When you create a session, you specify one of several acknowledge modes
for that session; these are described in link:#aeldl[Acknowledge Modes].
If you specify `MQ_CLIENT_ACKNOWLEDGE` as the acknowledge mode for the
session, you must explicitly call the `MQAcknowledgeMessages` function
to acknowledge messages that you have received. For more information,
see the description of the function link:#aeldp[MQAcknowledgeMessages].

You can use the link:#aelfp[MQReceiveMessageWait] function to block
while waiting for a message to arrive. You can use the
`MQReceiveMessageNoWait()` function if you do not want to wait for the
message to arrive.

[[gbmei]][[GMCCG00232]][[common-errors-35]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_SYNC_RECEIVE_MODE
MQ_CONCURRENT_ACCESS
MQ_TIMEOUT_EXPIRED
MQ_CONSUMER_CLOSED
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_THREAD_OUTSIDE_XA_TRANSACTION
MQ_XA_SESSION_NO_TRANSATION
----

[[aelfr]][[GMCCG00394]][[mqrecoversession]]

MQRecoverSession
^^^^^^^^^^^^^^^^

The `MQCRecoverSession` function stops message delivery and restarts
message delivery with the oldest unacknowledged message.

[source,oac_no_warn]
----
MQRecoverSession(const MQSessionHandle sessionHandle);
----

[[gbmev]][[GMCCG00233]][[return-value-59]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmdk]][[GMCCG00234]][[parameters-64]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session that you want to recover.

You can only call this function for sessions that are not transacted. To
rollback message delivery for a transacted session, use the
`MQRollBackSession ()` function. This function may be most useful if you
use the `MQ_CLIENT_ACKNOWELDGE` mode.

All consumers deliver messages in a serial order. Acknowledging a
received message automatically acknowledges all messages that have been
delivered to the client.

Restarting a session causes it to take the following actions:

* Stop message delivery in this session.
* Mark all messages that might have been delivered but not acknowledged
as redelivered.
* Restart the delivery sequence including all unacknowledged messages
that had been previously delivered. (Redelivered messages might not be
delivered in their original delivery order.)

[[gbmdm]][[GMCCG00235]][[common-errors-36]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_TRANSACTED_SESSION
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
----

[[aelfs]][[GMCCG00395]][[mqrollbacksession]]

MQRollBackSession
^^^^^^^^^^^^^^^^^

The `MQRollBackSession` function rolls back a transaction associated
with the specified session.

[source,oac_no_warn]
----
MQRollBackSession(const MQSessionHandle sessionHandle);
----

[[gbmdq]][[GMCCG00236]][[return-value-60]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmfa]][[GMCCG00237]][[parameters-65]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the transacted session that you want to roll back.

A transacted session groups messages into an atomic unit known as a
transaction. As messages are produced or consumed within a transaction,
the broker tracks the various sends and receives, completing these
operations only when you call the `MQCommitSession()` function.

If a send or receive operation fails, you must use the
`MQRollBackSession` function to roll back the entire transaction. This
means that those messages that have been sent are destroyed and those
messages that have been consumed are automatically recovered.

[[gbmer]][[GMCCG00238]][[common-errors-37]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_NOT_TRANSACTED_SESSION
MQ_CONCURRENT_ACCESS
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_XA_SESSION_IN_PROGRESS
----

[[aelft]][[GMCCG00396]][[mqsendmessage]]

MQSendMessage
^^^^^^^^^^^^^

The `MQSendMessage` function sends a message using the specified
producer.

[source,oac_no_warn]
----
MQSendMessage(const MQProducerHandle producerHandle,
                    const MQMessageHandle messageHandle);
----

[[gbmdw]][[GMCCG00239]][[return-value-61]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmed]][[GMCCG00240]][[parameters-66]]

Parameters
++++++++++

`producerHandle`::
  The handle to the producer sending this message. This handle is passed
  back to you by the link:#aelef[MQCreateMessageProducerForDestination]
  function.
`messageHandle`::
  A handle to the message you want to send.

The `MQSendMessage` function sends the specified message on behalf of
the specified producer to the destination associated with the message
producer. If you use this function to send a message, the following
message header fields are set to default values when the send completes.

* `MQ_PERSISTENT_HEADER_PROPERTY` will be set to
`MQ_PERSISTENT_DELIVERY`. +
This means that the calling thread will be blocked, waiting for the
broker to acknowledge receipt of your messages, unless you set the
connection property `MQ_ACK_ON_PRODUCE_PROPERTY` to `MQ_FALSE`.
* `MQ_PRIORITY_HEADER_PROPERTY` will be set to 4.
* `MQ_EXPIRATION_HEADER_PROPERTY` will be set to 0, which means that the
message will never expire.

If you set those message properties, they will be ignored when a message
is sent. To send a message with these properties set to different
values, you can use the link:#aelfu[MQSendMessageExt] function to
specify different values for these properties.

You cannot use this function with a producer that is created without a
specified destination.

[[gbmej]][[GMCCG00241]][[common-errors-38]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_PRODUCER_NO_DESTINATION
MQ_PRODUCER_CLOSED
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_THREAD_OUTSIDE_XA_TRANSACTION
MQ_XA_SESSION_NO_TRANSATION
----

[[aelfu]][[GMCCG00397]][[mqsendmessageext]]

MQSendMessageExt
^^^^^^^^^^^^^^^^

The `MQSendMessageExt` function sends a message using the specified
producer and allows you to specify selected message header properties.

[source,oac_no_warn]
----
MQSendMessageExt
                (const MQProducerHandle producerHandle,
                 const MQMessageHandle messageHandle
                 MQDeliveryMode msgDeliveryMode,
                 MQInt8 msgPriority,
                 MQInt64 msgTimeToLive);
----

[[gbmen]][[GMCCG00242]][[return-value-62]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmee]][[GMCCG00243]][[parameters-67]]

Parameters
++++++++++

`producerHandle`::
  The handle to the producer sending this message. This handle is passed
  back to you by the link:#aelef[MQCreateMessageProducerForDestination]
  function.
`messageHandle`::
  A handle to the message you want to send.
`msgDeliveryMode`::
  An enum +
  `MQ_PERSISTENT_DELIVERY` +
  `MQ_NONPERSISTENT_DELIVERY`
`msgPriority`::
  A integer value of 0 through 9; 0 being the lowest priority and 9 the
  highest.
`msgTimeToLive`::
  An integer value specifying in milliseconds how long the message will
  live before it expires. When a message is sent, its expiration time is
  calculated as the sum of its time-to-live value and current GMT. A
  value of 0 indicates that he message will never expire.

The `MQSendMessageExt` function sends the specified message on behalf of
the specified producer to the destination associated with the message
producer. Use this function if you want to change the default values for
the message header properties as shown in the next table.

Property::
  Default value
`msgDeliveryMode`::
  `MQ_PERSISTENT_DELIVERY`
`msgPriority`::
  4
`msgTimeToLive`::
  0, meaning no expiration limit

If you set these message headers using the `MQSetMessageHeaders`
function before the send, they will be ignored when the message is sent.
When the send completes, these message headers hold the values that are
set by the send.

You cannot use this function with a producer that is created without a
specified destination.

You can set the broker property `MQ_ACK_ON_PRODUCE_PROPERTY` to make
sure that the message has reached its destination on the broker:

* By default, the broker acknowledges receiving persistent messages
only.
* If you set the property to `MQ_TRUE`, the broker acknowledges receipt
of all messages (persistent and non-persistent) from the producing
client.
* If you set the property to `MQ_FALSE`, the broker does not acknowledge
receipt of any message (persistent or non-persistent) from the producing
client.

Note that "acknowledgement" in this case is not programmatic but
internally implemented. That is, the client thread is blocked and does
not return until the broker acknowledges messages it receives from the
producing client.

[[gbmdn]][[GMCCG00244]][[common-errors-39]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_PRODUCER_NO_DESTINATION
MQ_INVALID_PRIORITY
MQ_INVALID_DELIVERY_MODE
MQ_PRODUCER_CLOSED
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_THREAD_OUTSIDE_XA_TRANSACTION
MQ_XA_SESSION_NO_TRANSATION
----

[[aelfv]][[GMCCG00398]][[mqsendmessagetodestination]]

MQSendMessageToDestination
^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQSendMessageToDestination` function sends a message using the
specified producer to the specified destination.

[source,oac_no_warn]
----
MQSendMessageToDestination
            (const MQProducerHandle  producerHandle,
             const MQMessageHandle messageHandle,
             const MQDestinationHandle destinationHandle);
----

[[gbmdh]][[GMCCG00245]][[return-value-63]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmez]][[GMCCG00246]][[parameters-68]]

Parameters
++++++++++

`producerHandle`::
  The handle to the producer sending this message. This handle is passed
  back to you by the link:#aelee[MQCreateMessageProducer] function.
`messageHandle`::
  A handle to the message you want to send.
`destinationHandle`::
  A handle to the destination where you want to send the message.

The `MQSendMessageToDestination` function sends the specified message on
behalf of the specified producer to the specified destination. If you
use this function to send a message, the following message header fields
are set as follows when the send completes.

* `MQ_PERSISTENT_HEADER_PROPERTY` will be set to
`MQ_PERSISTENT_DELIVERY`. +
This means that the caller will be blocked, waiting for broker
acknowledgement for the receipt of your messages unless you set the
connection property `MQ_ACK_ON_PRODUCE_PROPERTY` to `MQ_FALSE`.
* `MQ_PRIORITY_HEADER_PROPERTY` will be set to 4.
* `MQ_EXPIRATION_HEADER_PROPERTY` will be set to 0, which means that the
message will never expire.

To send a message with these properties set to different values, you
must use the link:#aelfw[MQSendMessageToDestinationExt] function, which
allows you to set these three header properties.

If you set these message headers using the `MQSetMessageHeaders`
function before the send, they will be ignored when the message is sent.
When the send completes, these message headers hold the values that are
set by the send.

You cannot use this function with a producer that is created with a
specified destination.

[[gbmfn]][[GMCCG00247]][[common-errors-40]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_PRODUCER_HAS_DEFAULT_DESTINATION
MQ_PRODUCER_CLOSED
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_THREAD_OUTSIDE_XA_TRANSACTION
MQ_XA_SESSION_NO_TRANSATION
----

[[aelfw]][[GMCCG00399]][[mqsendmessagetodestinationext]]

MQSendMessageToDestinationExt
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQSendMessageToDestinationExt` function sends a message to the
specified destination for the specified producer and allows you to set
selected message header properties.

[source,oac_no_warn]
----
MQSendMessageToDestinationExt
          (const MQProducerHandle  producerHandle,
           const MQMessageHandle  messageHandle,
           const MQDestinationHandle  destinationHandle,
           MQDeliveryMode msgDeliveryMode,
           MQInt8 msgPriority,
           MQInt64 msgTimeToLive);
----

[[gbmgp]][[GMCCG00248]][[return-value-64]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmfc]][[GMCCG00249]][[parameters-69]]

Parameters
++++++++++

`producerHandle`::
  The handle to the producer sending this message. This handle is passed
  back to you when you call the link:#aelee[MQCreateMessageProducer]
  function.
`messageHandle`::
  A handle to the message you want to send.
`destinationHandle`::
  A handle to the destination where you want to send the message.
`msgDeliveryMode`::
  An enum of either `MQ_PERSISTENT_DELIVERY` or
  `MQ_NONPERSISTENT_DELIVERY`.
`msgPriority`::
  A integer value of 0 through 9; 0 being the lowest priority and 9 the
  highest.
`msgTimeToLive`::
  An integer value specifying in milliseconds how long the message will
  live before it expires. When a message is sent, its expiration time is
  calculated as the sum of its time-to-live value and current GMT. A
  value of 0 indicates that the message will never expire.

The `MQSendMessageToDestinationExt` function sends the specified message
on behalf of the specified producer to the specified destination. Use
this function if you want to change the default values for the message
header properties as shown below:

Property::
  Default value
`msgDeliveryMode`::
  `MQ_PERSISTENT_DELIVERY`
`msgPriority`::
  4
`msgTimeToLive`::
  0, meaning no expiration limit

If these default values suit you, you can use the
link:#aelfv[MQSendMessageToDestination] function to send the message.

You cannot use this function with a producer that is created with a
specified destination.

You can set the broker property `MQ_ACK_ON_PRODUCE_PROPERTY` to make
sure that the message has reached its destination on the broker:

* By default, the broker acknowledges receiving persistent messages only
from the producing client.
* If you set the property to `MQ_TRUE`, the broker acknowledges receipt
of all messages (persistent and non-persistent) from the producing
client.
* If you set the property to `MQ_FALSE`, the broker does not acknowledge
receipt of any message (persistent or non-persistent) from the producing
client.

Note that "acknowledgement" in this case is not programmatic but
internally implemented. That is, the client thread is blocked and does
not return until the broker acknowledges messages it receives.

[[gbmgn]][[GMCCG00250]][[common-errors-41]]

Common Errors
+++++++++++++

[source,oac_no_warn]
----
MQ_PRODUCER_HAS_DEFAULT_DESTINATION
MQ_INVALID_PRIORITY
MQ_INVALID_DELIVERY_MODE
MQ_PRODUCER_CLOSED
MQ_SESSION_CLOSED
MQ_BROKER_CONNECTION_CLOSED
MQ_THREAD_OUTSIDE_XA_TRANSACTION
MQ_XA_SESSION_NO_TRANSATION
----

[[aelfx]][[GMCCG00400]][[mqsetboolproperty]]

MQSetBoolProperty
^^^^^^^^^^^^^^^^^

The `MQSetBoolProperty` function sets an `MQBool` property with the
specified key to the specified value.

[source,oac_no_warn]
----
MQSetBoolProperty
               (const MQPropertiesHandle propertiesHandle,
                ConstMQString key,
                MQBool value);
----

[[gbmfl]][[GMCCG00251]][[return-value-65]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgh]][[GMCCG00252]][[parameters-70]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set.
`key`::
  The name of the property key. The library makes a copy of the property
  key.
`value`::
  The `MQBool` property value.

[[gbmgq]][[GMCCG00253]][[common-errors-42]]

Common Errors
+++++++++++++

`MQ_HASH_VALUE_ALREADY_EXISTS`

[[aelfy]][[GMCCG00401]][[mqsetbytesmessagebytes]]

MQSetBytesMessageBytes
^^^^^^^^^^^^^^^^^^^^^^

The `MQSetBytesMessageBytes` function defines the body for a bytes
message.

[source,oac_no_warn]
----
MQSetBytesMessageBytes 
                  (const MQMessageHandle messageHandle,
                   const MQInt8 * messageBytes,
                   MQInt32 messageSize);
----

[[gbmfx]][[GMCCG00254]][[return-value-66]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgx]][[GMCCG00255]][[parameters-71]]

Parameters
++++++++++

`messageHandle`::
  A handle to an `MQ_BYTES_MESSAGE` message whose body you want to set.
`messageBytes`::
  A pointer to the bytes you want to set. The library makes a copy of
  the message bytes.
`messageSize`::
  An integer specifying the number of bytes in `messageBytes` .

After you obtain the handle to a bytes message from
`MQCreateBytesMessage` , you can use this handle to define its body with
the link:#aelfy[MQSetBytesMessageBytes] function, to set its
application-defined properties with the
link:#aelgg[MQSetMessageProperties] function, and to set certain message
headers with the link:#aelgf[MQSetMessageHeaders] function.

[[CIAHJGHF]][[GMCCG465]][[mqsetdeliverydelay]]

MQSetDeliveryDelay
^^^^^^^^^^^^^^^^^^

The `MQSetDeliveryDelay` function defines the earliest time a JMS
provider may deliver a message to a consumer.

[source,oac_no_warn]
----
MQSetDeliveryDelay 
                  (const MQProducer producerHandle,
                   MQInt64 deliveryDelay);
----

[[GMCCG466]][[sthref44]]


[[return-value-67]]
Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[GMCCG467]][[sthref45]]


[[parameters-72]]
Parameters
++++++++++

`producerHandle`::
  The handle to the producer sending this message. This handle is passed
  back to you by the link:#aelef[MQCreateMessageProducerForDestination]
  function.
`deliveryDelay`::
  The amount of time, in milliseconds, used to delay a message's
  delivery time. +
  This value is added to the time the message was sent to calculate the
  delivery time, which is the earliest time that a JMS provider may
  deliver a message to a consumer. A JMS provider must not delivery
  messages before the delivery time has been reached. When specified,
  the `MQ_DELIVERY_TIME_HEADER_PROPERTY` is ignored.

[[aelfz]][[GMCCG00402]][[mqsetfloat32property]]

MQSetFloat32Property
^^^^^^^^^^^^^^^^^^^^

The `MQSetFloat32Property` function sets an `MQFloat32` property with
the specified key to the specified value.

[source,oac_no_warn]
----
MQSetFloat32Property
             (const MQPropertiesHandle propertiesHandle,
              ConstMQString key,
              MQFloat32 value);
----

[[gbmgi]][[GMCCG00256]][[return-value-68]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgz]][[GMCCG00257]][[parameters-73]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set.
`key`::
  The name of a property key. The library makes a copy of the property
  key.
`value`::
  The `MQFloat32` property value.

[[gbmgu]][[GMCCG00258]][[common-errors-43]]

Common Errors
+++++++++++++

`MQ_HASH_VALUE_ALREADY_EXISTS`

[[aelga]][[GMCCG00403]][[mqsetfloat64property]]

MQSetFloat64Property
^^^^^^^^^^^^^^^^^^^^

The `MQSetFloat64Property` function sets an `MQFloat64` property with
the specified key to the specified value.

[source,oac_no_warn]
----
MQSetFloat64Property
         (const MQPropertiesHandle propertiesHandle,
          ConstMQString key,
          MQFloat64 value);
----

[[gbmge]][[GMCCG00259]][[return-value-69]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmff]][[GMCCG00260]][[parameters-74]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set.
`key`::
  The name of a property key. The library makes a copy of the property
  key.
`value`::
  The `MQFloat64` property value.

[[gbmgd]][[GMCCG00261]][[common-errors-44]]

Common Errors
+++++++++++++

`MQ_HASH_VALUE_ALREADY_EXISTS`

[[aelgb]][[GMCCG00404]][[mqsetint16property]]

MQSetInt16Property
^^^^^^^^^^^^^^^^^^

The `MQSetInt16Property` function sets an `MQInt16` property with the
specified key to the specified value.

[source,oac_no_warn]
----
MQSetInt16Property
        (const MQPropertiesHandle propertiesHandle,
         ConstMQString key,
         MQInt16 value);
----

[[gbmgf]][[GMCCG00262]][[return-value-70]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmfh]][[GMCCG00263]][[parameters-75]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set.
`key`::
  The name of a property key. The library makes a copy of the property
  key.
`value`::
  The `MQInt16` property value.

[[gbmga]][[GMCCG00264]][[common-errors-45]]

Common Errors
+++++++++++++

`MQ_HASH_VALUE_ALREADY_EXISTS`

[[aelgc]][[GMCCG00405]][[mqsetint32property]]

MQSetInt32Property
^^^^^^^^^^^^^^^^^^

The `MQSetInt32Property` function sets an `MQInt32` property with the
specified key to the specified value.

[source,oac_no_warn]
----
MQSetInt32Property
          (const MQPropertiesHandle propertiesHandle,
           ConstMQString key,
           MQInt32 value);
----

[[gbmfe]][[GMCCG00265]][[return-value-71]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgr]][[GMCCG00266]][[parameters-76]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set.
`key`::
  The name of a property key. The library makes a copy of the property
  key.
`value`::
  The `MQInt32` property value.

[[gbmgj]][[GMCCG00267]][[common-errors-46]]

Common Errors
+++++++++++++

`MQ_HASH_VALUE_ALREADY_EXISTS`

[[aelgd]][[GMCCG00406]][[mqsetint64property]]

MQSetInt64Property
^^^^^^^^^^^^^^^^^^

The `MQSetInt64Property` function sets an `MQInt64` property with the
specified key to the specified value.

[source,oac_no_warn]
----
MQSetInt64Property
        (const MQPropertiesHandle propertiesHandle,
         ConstMQString key,
         MQInt64 value);
----

[[gbmfd]][[GMCCG00268]][[return-value-72]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmfk]][[GMCCG00269]][[parameters-77]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set.
`key`::
  The name of a property key. The library makes a copy of the property
  key.
`value`::
  The `MQInt64` property value.

[[gbmfr]][[GMCCG00270]][[common-errors-47]]

Common Errors
+++++++++++++

`MQ_HASH_VALUE_ALREADY_EXISTS`

[[aelge]][[GMCCG00407]][[mqsetint8property]]

MQSetInt8Property
^^^^^^^^^^^^^^^^^

The `MQSetInt8Property` function sets an `MQInt8` property with the
specified key to the specified value.

[source,oac_no_warn]
----
MQSetInt8Property
           (const MQPropertiesHandle propertiesHandle,
            ConstMQString key,
            MQInt8 value);
----

[[gbmfq]][[GMCCG00271]][[return-value-73]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmfv]][[GMCCG00272]][[parameters-78]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set
`key`::
  The name of a property key. The library makes a copy of the property
  key.
`value`::
  The `MQInt8` property value.

[[gbmfu]][[GMCCG00273]][[common-errors-48]]

Common Errors
+++++++++++++

`MQ_HASH_VALUE_ALREADY_EXISTS`

[[aelgf]][[GMCCG00408]][[mqsetmessageheaders]]

MQSetMessageHeaders
^^^^^^^^^^^^^^^^^^^

The `MQSetMessageHeaders` function creates the header part of the
message.

[source,oac_no_warn]
----
MQSetMessageHeaders
               (const MQMessageHandle messageHandle
                MQPropertiesHandle headersHandle);
----

[[gbmfs]][[GMCCG00274]][[return-value-74]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgs]][[GMCCG00275]][[parameters-79]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message.
`headersHandle`::
  A handle to the header properties object. This handle will be invalid
  after the function returns successfully.

After you have created a properties handle and defined values for
message header properties using one of the `MQSet...Property` functions,
you can pass the handle to the `MQSetMessageHeaders` function to define
the message header properties.

The message header properties are described in the table below. For
sending messages, the client can only set two of these: the correlation
ID property and the message type property. The client is not required to
set these; they are provided for the client's convenience. For example,
the client can use the key `MQ_MESSAGE_TYPE_HEADER_PROPERTY` to sort
incoming messages according to application-defined message types.

[[GMCCG468]][[sthref46]][[gbmfz]]


Table 4-6 Message Header Properties

[width="100%",cols="56%,20%,24%",options="header",]
|================================
|Key |Type |Set By
a|
[source,oac_no_warn]
----
MQ_CORRELATION_ID_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQString
----

 |Client (optional)
a|
[source,oac_no_warn]
----
MQ_MESSAGE_TYPE_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQString
----

 |Client (optional)
a|
[source,oac_no_warn]
----
MQ_PERSISTENT_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQBool
----

 |Send function
a|
[source,oac_no_warn]
----
MQ_EXPIRATION_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQInt64
----

 |Send function
a|
[source,oac_no_warn]
----
MQ_PRIORITY_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQInt8
----

 |Send function
a|
[source,oac_no_warn]
----
MQ_TIMESTAMP_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQInt64
----

 |Send function
a|
[source,oac_no_warn]
----
MQ_MESSAGE_ID_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQString
----

 |Send function
a|
[source,oac_no_warn]
----
MQ_REDELIVERED_HEADER_PROPERTY
----

 a|
[source,oac_no_warn]
----
MQBool
----

 |Message Broker
|================================


Header properties that are not specified in the `headersHandle` are not
affected. You cannot use this function to override header properties
that are set by the broker or the send function. The header properties
for persistence, expiration, and priority `(MQSetMessageHeaders)()` are
set to default values if the user called the `MQSendMessage()` or
`MQSendMessageToDestination()` function, or they are set to values the
user specifies (in parameters) if the user called the
`MQSendMessageExt ()` or the `MQSendMessageToDestinationExt()` function.

Use the `MQSetBytesMessageBytes()` function or the
`MQSetTextMessageText()` function to set the body of a message. Use the
link:#aelgg[MQSetMessageProperties] function to set the
application-defined properties of a message that are not part of the
header.

[[gbmgc]][[GMCCG00276]][[common-errors-49]]

Common Errors
+++++++++++++

`MQ_PROPERTY_WRONG_VALUE_TYPE`

[[aelgg]][[GMCCG00409]][[mqsetmessageproperties]]

MQSetMessageProperties
^^^^^^^^^^^^^^^^^^^^^^

The `MQSetMessageProperties` function sets the specified properties for
a message. You can also use this function to change a message's
properties.

[source,oac_no_warn]
----
MQSetMessageProperties
             (const MQMessageHandle messageHandle,
              MQPropertiesHandle propsHandle);
----

[[gbmfp]][[GMCCG00277]][[return-value-75]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgl]][[GMCCG00278]][[parameters-80]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message whose application-defined properties you want to
  set.
`propertiesHandle`::
  A handle to a properties object that you have created and set using
  one of the set property functions. This handle is invalid after the
  function returns successfully.

After you obtain the handle to a message, you can use this handle to
define its body with the `MQSetBytesMessageBytes()` or
`MQSetTextMessageText()` function, and to set its header properties with
the `MQSetMessageHeaders()` function.

Property values are set prior to sending a message. The
`MQSetMessageProperties` function allows you to set application-defined
properties for a message. For example, application-defined properties
allow an application, via message selectors, to select or filter,
messages on its behalf using application-specific criteria.

You define the message properties and their values using the
link:#aeleg[MQCreateProperties] function to create a properties object,
then you use one of the set property functions to define each key and
value in it. See link:using-the-c-api.html#aelbd[Working With Properties]
for more information.

[[aelgh]][[GMCCG00410]][[mqsetmessagereplyto]]

MQSetMessageReplyTo
^^^^^^^^^^^^^^^^^^^

The `MQSetMessageReplyTo` function specifies the destination where
replies to this message should be sent.

[source,oac_no_warn]
----
MQSetMessageReplyTo
         (const MQMessageHandle messageHandle,
          const MQDestinationHandle   destinationHandle);
----

[[gbmfg]][[GMCCG00279]][[return-value-76]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgk]][[GMCCG00280]][[parameters-81]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message expecting a reply.
`destinationHandle`::
  The destination to which the reply is sent. Usually this is a handle
  to a destination that you created using the
  link:#aeleb[MQCreateDestination] function or the function
  link:#aelei[MQCreateTemporaryDestination]. The handle is still valid
  when this function returns.

The sender uses the `MQSetMessageReply` function to specify a
destination where replies to the message can be sent. This can be a
normal destination or a temporary destination. The receiver of a message
can use the link:#aelfc[MQGetMessageReplyTo] function to determine
whether a sender has set up a destination where replies are to be sent.
The advantage of setting up a temporary destination for replies is that
Message Queue automatically creates a physical destination for you,
rather than your having to have the administrator create one if the
broker's `auto_create_destination` property is turned off.

[[aelgi]][[GMCCG00411]][[mqsetstringproperty]]

MQSetStringProperty
^^^^^^^^^^^^^^^^^^^

The `MQSetStringProperty` function sets an `MQString` property with the
specified key to the specified value.

[source,oac_no_warn]
----
MQSetStringProperty
                 (const MQPropertiesHandle propertiesHandle,
                  ConstMQString key,
                  ConstMQString value);
----

[[gbmgb]][[GMCCG00281]][[return-value-77]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgo]][[GMCCG00282]][[parameters-82]]

Parameters
++++++++++

`propertiesHandle`::
  A handle to the properties object whose property value for the
  specified key you want to set. You get this handle from the
  `MQCreateProperties ()` function.
`key`::
  The name of a property key. The library makes a copy of the property
  key
`value`::
  The property value to set. The library makes a copy of the value.

The library makes a copy of the property key and also makes a copy of
the value.

[[aelgj]][[GMCCG00412]][[mqsettextmessagetext]]

MQSetTextMessageText
^^^^^^^^^^^^^^^^^^^^

The `MQSetTextMessageText` function defines the body for a text message.

[source,oac_no_warn]
----
MQSetTextMessageText
               (const MQMessageHandle messageHandle,
                ConstMQString messageText);
----

[[gbmgv]][[GMCCG00283]][[return-value-78]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmfm]][[GMCCG00284]][[parameters-83]]

Parameters
++++++++++

`messageHandle`::
  A handle to a message whose text body you want to set.
`messageText`::
  An `MQString` specifying the message text. The library makes a copy of
  the message text.

After you obtain the handle to a text message, you can use this handle
to define its body with the `MQSetTextMessageText()` function. You can
set its application-defined properties with the
link:#aelgg[MQSetMessageProperties] function, and you can set certain
message headers with the link:#aelgf[MQSetMessageHeaders] function.

[[aelgk]][[GMCCG00413]][[mqstartconnection]]

MQStartConnection
^^^^^^^^^^^^^^^^^

The `MQStartConnection` function starts the specified connection to the
broker and starts or resumes message delivery.

[source,oac_no_warn]
----
MQStartConnection
             (const MQConnectionHandle connectionHandle);
----

[[gbmfj]][[GMCCG00285]][[return-value-79]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmgg]][[GMCCG00286]][[parameters-84]]

Parameters
++++++++++

`connectionHandle`::
  The handle to the connection that you want to start. This handle is
  the handle that is created and passed back to you by the
  link:#aeldy[MQCreateConnection] function.

When a connection is created it is in stopped mode. Until you call this
function, messages are not delivered to any consumers. Call this
function to start a connection or to restart a connection that has been
stopped with the `MQStopConnection()` function. To create an
asynchronous consumer, you could have the connection in stopped mode,
and start or restart the connection after you have set up the
asynchronous message consumer.

Use the link:#aeldq[MQCloseConnection] function to close a connection,
and then use the link:#aelek[MQFreeConnection] function to free the
memory allocated to the connection.

[[gbmgy]][[GMCCG00287]][[common-errors-50]]

Common Errors
+++++++++++++

`MQ_BROKER_CONNECTION_CLOSED`

[[aelgl]][[GMCCG00414]][[mqstatusiserror]]

MQStatusIsError
^^^^^^^^^^^^^^^

The `MQStatusIsError` function returns `MQ_TRUE` if the `status`
parameter passed to it represents an error.

[source,oac_no_warn]
----
MQBool MQStatusIsError(const MQStatus status);
----

[[gbmfy]][[GMCCG00288]][[parameters-85]]

Parameters
++++++++++

`status`::
  The status returned by any Message Queue function that returns an
  `MQStatus`.

Nearly all Message Queue C library functions return an `MQStatus`. You
can pass this status result to the `MQStatusIsError` function to
determine whether your call succeeded. If the `MQStatusIsError` function
returns `MQ_TRUE(=1)`, the function failed; if it returns
`MQ_FALSE(=0),` the function returned successfully.

If the `MQStatusIsError` returns `MQ_TRUE`, you can get more information
about the error that occurred by passing the `status` returned to the
link:#aelfg[MQGetStatusCode] function. This function will return the
error code associated with the specified status.

To obtain an `MQString` that describes the error, use the
link:#aelfh[MQGetStatusString] function. To get an error trace
associated with the error, use the link:#aelet[MQGetErrorTrace]
function.

[[aelgm]][[GMCCG00415]][[mqstopconnection]]

MQStopConnection
^^^^^^^^^^^^^^^^

The `MQStopConnection` function stops the specified connection to the
broker. This stops the broker from delivering messages.

[source,oac_no_warn]
----
MQStopConnection
               (const MQConnectionHandle connectionHandle);
----

[[gbmfi]][[GMCCG00289]][[return-value-80]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmfo]][[GMCCG00290]][[parameters-86]]

Parameters
++++++++++

`connectionHandle`::
  The handle to the connection that you want to stop. This handle is
  passed back to you by the link:#aeldy[MQCreateConnection] function.

You can restart message delivery by calling the
link:#aelgk[MQStartConnection] function. When the connection has
stopped, delivery to all the connection's message consumers is
inhibited: synchronous receives block, and messages are not delivered to
message listeners. This call blocks until receives and/or message
listeners in progress have completed.

You should not call `MQStopConnection` in a message listener callback
function.

Use the link:#aeldq[MQCloseConnection] function to close a connection,
and then use the link:#aelek[MQFreeConnection] function to free the
memory allocated to the connection.

[[gbmgm]][[GMCCG00291]][[common-errors-51]]

Common Errors
+++++++++++++

`MQ_BROKER_CONNECTION_CLOSED` +
`MQ_CONCURRENT_DEADLOCK`

[[aelgn]][[GMCCG00416]][[mqunsubscribedurablemessageconsumer]]

MQUnsubscribeDurableMessageConsumer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The `MQUnsubscribeDurableMessageConsumer` function unsubscribes the
specified durable message consumer.

[source,oac_no_warn]
----
MQUnsubscribeDurableMessageConsumer
                    (const MQSessionHandle   sessionHandle,
                     ConstMQString durableName);
----

[[gbmfw]][[GMCCG00292]][[return-value-81]]

Return Value
++++++++++++

`MQStatus`. See the link:#aelgl[MQStatusIsError] function for more
information.

[[gbmft]][[GMCCG00293]][[parameters-87]]

Parameters
++++++++++

`sessionHandle`::
  The handle to the session to which this consumer belongs. This handle
  is created and passed back to you by the link:#aeleh[MQCreateSession]
  function.
`durableName`::
  An `MQString` specifying the name of the durable subscriber.

When you call the `MQUnsubscribeDurableMessageConsumer` function, the
client runtime instructs the broker to delete the state information that
the broker maintains for this consumer. If you try to delete a durable
consumer while it has an active topic subscriber or while a received
message has not been acknowledged in the session, you will get an error.
You should only unsubscribe a durable message consumer after closing it.

[[gbmgt]][[GMCCG00294]][[common-errors-52]]

Common Errors
+++++++++++++

`MQ_CANNOT_UNSUBSCRIBE_ACTIVE_CONSUMER` +
`MQ_CONSUMER_NOT_FOUND`

[[aelgo]][[GMCCG00058]][[header-files]]

Header Files
~~~~~~~~~~~~

The Message Queue C-API is defined in the header files listed in
link:#gbmhk[Table 4-7]. The files are listed in alphabetical order. The
file `mqcrt.h` includes all the Message Queue C-API header files.

[[GMCCG469]][[sthref47]][[gbmhk]]


Table 4-7 Message Queue C-API Header Files

[width="100%",cols="26%,74%",options="header",]
|=======================================================================
|File Name |Contents
a|
[source,oac_no_warn]
----
mqbasictypes.h
----

 |Defines the types `MQBool`, `MQInt8`, `MQInt16`, `MQInt32`, `MQInt64`,
`MQFloat32`, `MQFloat64`.

a|
[source,oac_no_warn]
----
mqbytes-message.h
----

 |Function prototypes for creating, getting, setting bytes message.

a|
[source,oac_no_warn]
----
mqcallback-types.h
----

 |Asynchronous receive and connection exception handling callback types.

a|
[source,oac_no_warn]
----
mqconnection.h
----

 |Function prototypes for creating, managing, and closing connections.
Function prototype for creating session.

a|
[source,oac_no_warn]
----
mqconnection-props.h
----

 |Connection property constants

a|
[source,oac_no_warn]
----
mqconsumer.h
----

 |Function prototypes for synchronous receives and closing the consumer.

a|
[source,oac_no_warn]
----
mqcrt.h
----

 |All Message Queue C-API public header files.

a|
[source,oac_no_warn]
----
mqdestination.h
----

 |Function prototypes to free destinations and get information about
destinations.

a|
[source,oac_no_warn]
----
mqerrors.h
----

 |Error codes

a|
[source,oac_no_warn]
----
mqheader-props.h
----

 |Message header property constants

a|
[source,oac_no_warn]
----
mqmessage.h
----

 |Function prototypes for getting and setting parts of message, freeing
message, and acknowledging message.

a|
[source,oac_no_warn]
----
mqproducer.h
----

 |Function prototypes for sending messages and closing the message
producer.

a|
[source,oac_no_warn]
----
mqproperties.h
----

 |Function prototypes for creating, setting, and getting properties

a|
[source,oac_no_warn]
----
mqsession.h
----

 |Function prototypes for managing and closing sessions; for creating
destinations, message producers and message consumers.

a|
[source,oac_no_warn]
----
mqssl.h
----

 |Function declaration for initializing the SSL library.

a|
[source,oac_no_warn]
----
mqstatus.h
----

 |Function prototypes for getting error information.

a|
[source,oac_no_warn]
----
mqtext-message.h
----

 |Function prototypes for creating, getting, setting text message.

a|
[source,oac_no_warn]
----
mqtypes.h
----

 |Enumeration of types that can be stored in a properties object, of
types of message that can be received, of acknowledgement modes, of
delivery modes, of destination types, of session receiving modes, and of
handle types.

a|
[source,oac_no_warn]
----
mqversion.h
----

 |Version information constant definitions.
|=======================================================================



